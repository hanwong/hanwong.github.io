{"meta":{"title":"Woong's blog.","subtitle":null,"description":null,"author":"Woong","url":"http://hanwong.github.io"},"pages":[{"title":"About","date":"2018-06-22T14:46:25.000Z","updated":"2018-06-22T14:46:25.000Z","comments":true,"path":"about/index.html","permalink":"http://hanwong.github.io/about/index.html","excerpt":"","text":"An evangelist who wants to spread the gospel to the ends of the earth by coding. 2018.03 - Current : Front-end Developer at Sentbe 2016.11 - 2017.12 : Front-end Developer at NewsJelly 2014.03 - 2016.04 : UX Designer at pxd"},{"title":"Categories","date":"2017-05-06T05:20:20.000Z","updated":"2017-05-06T05:23:48.000Z","comments":true,"path":"categories/index.html","permalink":"http://hanwong.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-05-06T05:22:27.000Z","updated":"2017-05-06T05:23:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://hanwong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"코드스피츠 - 객체지향프로그래밍과 디자인패턴","slug":"codespitz-01","date":"2019-06-01T15:00:00.000Z","updated":"2019-06-06T08:44:55.958Z","comments":true,"path":"2019/06/02/codespitz-01/","link":"","permalink":"http://hanwong.github.io/2019/06/02/codespitz-01/","excerpt":"코드스피츠 강의 중 객체지향프로그래밍과 디자인패턴에 대한 전반적인 개념 및 철학과 몇몇 디자인패턴들의 특징에 대해서 학습한 내용을 공유하고자 합니다. 코드스피츠 3rd-4 ES6+ 디자인패턴과 뷰패턴 2회차를 직접 보신 후에 복습용으로 이 글을 읽어 보시길 추천합니다.","text":"코드스피츠 강의 중 객체지향프로그래밍과 디자인패턴에 대한 전반적인 개념 및 철학과 몇몇 디자인패턴들의 특징에 대해서 학습한 내용을 공유하고자 합니다. 코드스피츠 3rd-4 ES6+ 디자인패턴과 뷰패턴 2회차를 직접 보신 후에 복습용으로 이 글을 읽어 보시길 추천합니다. 객체지향 프로그래밍을 구현하기 위한 두가지 속성 이 두가지 성질을 가져야지만 객체지향 프로그래밍이 가능한 언어라고 할 수 있습니다. 이 성질은 언어마다 매커니즘이 다릅니다. 1. 대체가능성 폴리모피즘 하위형은 상위형(추상형)을 대신 할 수 있다. 확장된형은 확장이전형을 대체 할 수 있다 자식은 부모를 대신 할 수 있다. 12345const Parent = class &#123;&#125;;const Child = class extends Parent&#123;&#125;;const a = new Child();console.log(a instanceof Parent); // true// Child는 Parent를 대신 할 수 있어! 를 의미하는 코드입니다. 이 구조는 몇단계로 확장 되어도 그 윗단계는 대체 할 수 있다는 뜻 객체지향언어는 이것을 만족하는 장치가 있어야 한다. 자바스크립트에서는 프로토타입 체인에 의해서 __proto__가 기록되어 있는 객체 간의 체인으로 그 체인을 다 조사해서 그 중에 한 객체라도 걸리면 instanceof가 성립하는 결과를 만족시키고 있다. 2. 내적일관성(내적동질성)12345678910111213141516const Parent = class &#123; wrap() &#123; this.action(); &#125; action() &#123; console.log('Parent'); &#125;&#125;;const Child = class extends Parent&#123; action() &#123; console.log('Child'); &#125;&#125;;const a = new Child();a.wrap(); // Child 내적동질성 이란 아무리 확장되기 전 객체들의 메소드나 다른 객체들의 메소드 계층 상에 있는 메소드를 호출해도 본래 객체의 본질은 변하지 않는다는 의미…?? 나의 본질은 Child이기 때문에 Parent로 보려고 해도 나의 본질은 Child라는 의미… 태생을 그대로 유지하려는 성질 대체가능성과, 내적동질성 이 두가지 성질이 객체지향의 학술적 정의이고 언어에서 어떤 방법으로든 지원을 해야지만 객체지향 언어라 할 수 있다. 디자인패턴 GOF의 디자인패턴 분류 - 생성패턴, 구조패턴, 행동패턴… 이런건 객체지향 설계가 익숙해진 후에 공부하는 걸로… 객체지향 설계를 위한 다양한 원리들이 있지만 … 격리를 통한 역할모델을 구현하는 것에 대해서 집중적으로 보려고 합니다. 디자인패턴을 역할모델을 기준으로 분류해서 어떤 방식으로 무슨 역할을 분리하기 위해 무슨 패턴을 쓰는지~ 라는 관점으로 학습해보고자 합니다. 디자인패턴과 제어문 기반의 알고리즘이 갖는 문제점 기존 제어문 기반으로 알고리즘을 짜면 코드 한줄만 수정을 해도 영향이 가는 모든 코드를 테스트 해봐야 한다. 코드를 건드리는것 자체가 엄청난 일이 된다. 알고리즘이 변화하는 부분만 수정하고 나머지는 건드리고 싶지 않다면? 123if(case == 1) &#123; ... &#125;else if(case == 2) &#123; ... &#125;else if(case == 3) &#123; ... &#125; 코드를 안건드리고 어떻게 if를 조정하지? 이 질문이 아키텍쳐 이하 모든 디자인패턴의 원형적인 목표이다. 문제1. 경우가 변경될 때 문제2. 함수 간 공통부분 프로시져 지향, 공통 의존 데이터 문제, 상태에 대한 의존성이 강해지기 때문에 복잡해질수록 프로시져를 나눌수록 더욱더 원본 데이터의 수정이 불가능해진다. 절차지향적으로 어딘가 데이터의 바인딩이 많이 되게 개발을 하게 되면 변화를 수용할 수 없게 되고 데이터의 구조나 목표가 조금만 바뀌어도 프로그램 전체를 다시 개발하게 된다. 이 문제를 해결하기 위해 객체지향이 나온것이다. 프로시져가 가리키는 데이터를 은닉하고 캡슐화하여 노출해야지? 데이터를 쉐어하는 것이 문제의 원인이니까 원천적으로 데이터를 공유하지 못하도록 하겠다는 것이 객체지향이다. 문제는 절차가 아니라 절차들이 공유하고 있는 데이터인것이다. 이를 해결하기 위해서 데이터를 절차와 강력하게 바인딩하여 은닉시키고, 표준화된 메세지로만 통신하여 협력하는 모델로 바꿔 나간다. 데이터에 대한 서로간의 의존성이 없어지기 때문에 우리는 부분적으로 격리를 시킬수 있게 되는 것이 객체지향의 시발점이다. 알고리즘 분화 시 객체지향에서 선택할 수 있는 두가지 방법 상속위임 - 내부계약관계로 추상층에서 공통 요소를 해결하고 상태를 공유 할 수 있음. 공통 부분을 처리하기 위해 사용한다. 나는 너를 알지의 개념. 확장된 쪽이 부모쪽을 아는 것. 상속위임은 내부사정으로 약속이 확정되어 있다. 객체간 내부사정을 다 안다고 하면 통신을 따로 약속하지 않고 훨씬 더 안전하게 통신 할 수 있다는 장점이 있다. 소유위임 - 외부계약관계로 각각이 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결함. 내 할일하고 나머지는 맡기는 방법. 소유위임은 분리된 객체끼리 통신할 통신망을 확보해야만 한다. 독립되어 있는 객체간의 약속이 필요하다. 객체망을 구성한다고도 함. 어찌됬든 소유와 상속을 사용하는 이유는 케이스에 대응하기 위해서와 케이스에 대한 처리를 확장하기 위해서이다. 디자인패턴은 소유위임을 위주로 설명한다. 디자인패턴을 사용하면 여러가지 프로토콜, 객체 간의 통신하는 층을 만들어 줘야 한다. 부속물이 많이 생기게 된다. 더 넗게 더 관계 없는 것과도 통신할 수 있게 하고 싶은 것.\u001f 연결해야 하는 대상이 많으면 많을수록 소유위임이 훨씬 유리해진다. 소유위임은 케이스의 확장, 처리기의 확장을 더 멀리 넓게 퍼뜨릴 수 있지만 처리속도는 낮아지고 더 많은 부하를 걸게 될 수도 있다. 상속위임은 그 반대가 일어난다. 속도와 메모리는 바꿀 수 있다. 상속위임은 속도나 효율이 좋아지고, 소유위임은 메모리를 많이 사용하는 방식이다. 소유위임은 더 많은 경우의 수를 처리 할 수 있는 범용적인 솔루션으로써의 패턴을 제안하는것이다. 1. 상속위임12345678910111213141516171819202122232425262728/////// TEMPLATE METHOD PATTERN //////const Github = class &#123; ////// 정의시점 - 변하지 않는 부분 ////// constructor(id, repo) &#123; this._base = `https://api.github.com/repos/$&#123;id&#125;/$&#123;repo&#125;/contents/`; &#125; load(path) &#123; /////////////////// 공통부부분 - start /////////////////// const id = 'callback' + Github._id++; const f = Github[id] = (&#123;data: &#123;content&#125;&#125;) =&gt; &#123; delete Github[id]; document.head.removeChild(s); /////// 위임부분 - start /////// this._loaded(content); /////// 위임부분 - end /////// &#125;; const s = document.createElement('script'); s.src = `$&#123;this._base + path&#125;?callback=Github.$&#123;id&#125;`; document.head.appendChild(s); /////////////////// 공통부부분 - end /////////////////// &#125; _loaded(v)&#123;throw 'override!'&#125;; /////// HOOK //////&#125;;Github._id = 0;const ImageLoader = class extends Github &#123; ////// 실행시점 - 변하는 부분 ////// _loaded(v) &#123;...&#125;&#125;; 위 코드는 상속위임을 위한 기본 골격이 되는 코드이다. 공통부분은 이미지를 로딩하던지 텍스트를 로딩하던지 이 로직은 변하지 않는 부분이다. 위임부분이 변하는 부분이고, if 케이스 별로 바뀌어야 하는 부분이다. 위임부분을 내적동질성을 이용해서 서브클래스에게 위임하는 것이다. 자식 별로 다르게 처리해야 하는 부분만 처리 할 수 있도록 하는 것이다. 코드를 격리 할 수 있다. ImageLoader는 Github이라는 것을 상속 받아서 _loaded만 오버라이드해서 작성하면 이미지를 로드하는 동작을 하게 될것입니다. 정의시점 부분을 건드리지 않고도 다양한 경우를 새로운 클래스만 추가해서 만들 수 있게 된다. 12345678910111213141516const ImageLoader = class extends Github &#123; constructor(id, repo, target) &#123; super(id, repo); this._target = target; &#125; _loaded(v) &#123; this._target.src = 'data:text/plain;base64,' + v; &#125;&#125;;const woongImg = new ImageLoader( 'hanwong', 'codespitz', document.querySelector('#a'))woomgImg.load('test.png'); 1234567891011121314151617181920212223242526const MdLoader = class extends Github &#123; constructor(id, repo, target) &#123; super(id, repo); this._target = targe; &#125; _loaded(v) &#123; this._target.innerHTML = this._parseMD(v); &#125; _parseMD(v) &#123; return d64(v).split('\\n').map(v =&gt; &#123; let i = 3; while(i--) &#123; if(v.startsWith('#'.repeat(i+1))) &#123; return `&lt;h$&#123;i+1&#125;&gt;$&#123;v.substr(i+1)&#125;&lt;/h$&#123;i+1&#125;&gt;`; &#125; &#125; return v; &#125;).join('&lt;br&gt;'); &#125;&#125;const d64 = v =&gt; decodeURIComponent( atob(v).split('').map(c =&gt; '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));const woongMd = new MdLoader('hanwong', 'codespitz'. document.querySelector('#b'));woongMd.load('README.md'); 이처럼 상속구현으로 if의 분기를 해결할 수 있다. image일 때, md일 때… 1234567891011121314&lt;!-- 정의 시점 - start --&gt;&lt;script src=\"Github.js\"&gt;&lt;/script&gt;&lt;script src=\"ImageLoader.js\"&gt;&lt;/script&gt;&lt;script src=\"MdLoader.js\"&gt;&lt;/script&gt;&lt;!-- 정의 시점 - end --&gt;&lt;script&gt; /////// 실행 시점 선택 - start /////// const img = new ImageLoader(...); img.load(...); const md = new MdLoader(...); md.load(...); /////// 실행 시점 선택 - end ///////&lt;/script&gt; if else 는 정의시점에서 확정되었었다. 지금 구조에서는 파일을 추가 할 때 마다 케이스를 추가 할 수 있다. 뿐만 아니라 실행시점에서 사용될 때 코드에서 경우의 수의 분기를 담당하게 된다. 정의시점에 분기하던 것을 실행시점으로 밀어낸 것이다. if else 를 제거하는 유일한 방법은 케이스 만큼의 객체를 만든 다음에 그 객체의 선택을 런타임으로 위임해버리는 수 밖에 없다라고 표현하는 것이다. 기저층에서 if else를 제거한 것 뿐이지 절대로 사라지지는 않는다. OOP는 결국 if else를 어떻게 제거하고 밑으로 밀어버릴까, 런타임에 결정 할 수 있는 권한으로 바꿔줄까, 되도록이면 정의시점에서 한단계라도 더 밑으로 내릴까? 하위 레이어로 내릴 때 마다 비용은 발생 할 수 밖에 없다. 케이스 만큼 객체를 만들어야 하고 결국 다음번 런타임에 선택하는 로직으로 옮겨질 뿐이다. 어떤 패턴을 써도 이 본질은 변하지 않는다. 2. 소유위임12345678910111213141516171819202122////// STARATEGY PATTERN //////const Github = class &#123; constructor(id, repo) &#123; this._base = `https://api.github.com/repos/$&#123;id&#125;/$&#123;repo&#125;/contents/`; &#125; load(path) &#123; if(!this._parser) return; const id = 'callback' + Github._id++; const f = Github[id] = (&#123;data: &#123;content&#125;&#125;) =&gt; &#123; delete Github[id]; document.head.removeChild(s); this._parser(content); ////// 위임부분 ////// &#125;; const s = document.createElement('script'); s.src = `$&#123;this._base + path&#125;?callback=Github.$&#123;id&#125;`; document.head.appendChild(s); &#125; ////// STARATEGY OBJECT ////// set parser(v)&#123;this._parser = v;&#125;; ////// 위임객체 //////&#125;Github._id = 0; 상속위임 코드와 비슷해 보이지만 소유를 나타내는 메소드가 추가되었다. set parser(...)로 _parser를 받아들이게 되어 있다. 상속계열의 this 메소드를 호출하는것이 아니라 소유하게 된 외뷔객체인 _parser에게 위임을 하게 되는것이다. 소유위임을 하게 되면 내가 소유할 객체들을 원본 객체에게 전달할 책임이 생기게 된다. 이것을 injection 주입이라고 한다. 위임부분을 위임객체가 처리해준다. override나 내부의 hook을 이용한 템플릿메소드패턴을 소유모델로 바꾸게 되면 전략패턴으로 바뀌게 된다. 그래서 템플릿메소드패턴과 전략패턴은 형제 관계이다. 같은 내용을 상속위임으로 구현할 것인지 소유위임으로 구현할 것인지의 차이이다. 템플릿메소드패턴는 내적일관성 원리를 이용하여 상속을 통해서 상속된 인스턴스가 처리를 했었는데 전략패턴은 소유객체에게 전달하면 되니까 내적일관성을 사용하지 않고 있다. 이렇게 소유위임은 객체지향의 개념을 덜 사용하고도 같은 기능을 처리할 수 있게 된다. 정의시점이 Github클래스 자체가 되는 것이고, 더이상 정의시점에 서브 클래스는 안나오게 되고, 받아온 객체를 실행시점에 받아서 처리하게 된다. 받아온 객체 자체가 런타임 객체가 된다. 12345678910111213const el = v =&gt; document.querySelector(v);const parseMD = v =&gt; ... ;const loader = new Github('hanwong', 'codespitz');// imgLoaderconst img = v =&gt; el('#a').src = 'data:text/plain;base64,' + v;loader.parser = img;loader.load('test.png');// mdLoaderconst md = v =&gt; el('#b').innerHTML = parserMD(v);loader.parser = md;loader.load('README.md'); 새로운 객체를 만들지 않고 parser만 변경하여서 바로 실행시킬수 있다. 이 부분이 템플릿메소드패턴과 전략패턴의 가장 큰 차이점이다. 템플릿메소드패턴은 이미지로더를 사용하려면 이미지로더 기능만 하는 단일적인 책임을 가지는 인스턴스를 생성해줘야 하지만 전략패턴은 이미 정의된 객체를 가지고 몇 번이고 재활용 할 수 있다. mutation이 일어난다고 한다. mutation은 개발자가 흐름을 기억해야 할 부분이 많이 생긴다. 3. 커맨드패턴12345678910111213141516171819202122////// COMMAND PATTERN //////const Github = class &#123; constructor(id, repo) &#123; this._base = `https://api.github.com/repos/$&#123;id&#125;/$&#123;repo&#125;/contents/`; &#125; load(path) &#123; if(!this._parser) return; const id = 'callback' + Github._id++; const f = Github[id] = (&#123;data: &#123;content&#125;&#125;) =&gt; &#123; delete Github[id]; document.head.removeChild(s); this._parser[0](content, ...this._parser[1]); ////// 커맨드 인보커 ////// &#125;; const s = document.createElement('script'); s.src = `$&#123;this._base + path&#125;?callback=Github.$&#123;id&#125;`; document.head.appendChild(s); &#125; setParser(f, ...arg)&#123; this._parser = [f, arg]; ////// 커맨드 객체화 ////// &#125;Github._id = 0; 전략패턴 객체는 정해진 행동을 계속 일으키는 인스턴스이거나 함수인데 커맨드패턴은 특정 호출 상태를 박제해서 몇번이고 재현할 수 있는 패턴을 의미한다. 그러면 전략패턴에서 나온 객체가 커맨드패턴이 되려면 단지 인자만 기억해줘도 충분하다. 우리가 함수 호출이라는 것을 문으로 적으면 문에서는 실행되고 휘발되서 아무것도 안남는다. 문은 인터프리터가 실행될 때 쓰이고 다 없어진다. 함수를 콜하는것도 문으로 구성하면 문은 호출하고나면 사라지기 때문에 호출을 재현할 수가 없다. 몇번이고 같은 형태로 호출을 하려면 함수와 인자1, 2, 3이 저장되 있어야지만 계속 호출 할 수 있는 상황을 재현할 수 있다. 어떤 문이 실행되는 환경을 저장하는 행위, 어떤 문이 실행되는 커맨드를 저장해두는 것을 커맨드패턴이라고 한다. 전략패턴과 달라진 점은 parser 함수가 그냥 실행 되는 것이 아니라 인자를 포함해서 실행된다는 환경까지 저장해서 몇번이고 다시 재현 할 수 있게 바꿔주면 그것이 커맨드패턴의 철학을 따르게 되는 것이다. 전략패턴 객체와 커맨드패턴 객체가 달라지것이 아니라 전략패턴객체를 커맨드패턴객체화시켜 버린 것이다. 커맨드패턴은 다음번에 똑같은 제어문을 재현 할 수 있는 환경을 저장해두는 커맨드객체와 이 저장된 것을 실행하는 실행기로 나누어진다.이 실행기를 커맨드패턴에서는 인보커라고 부른다. 디자인패턴에서 인보커라고 하면 뭔가 실행시켜주는 러너라고 생각하면 된다. 12345678910111213const el = v =&gt; document.querySelector(v);const parseMD = v =&gt; ... ;const loader = new Github('hanwong', 'codespitz');// imgLoaderconst img = (v, el) =&gt; el.src = 'data:text/plain;base64,' + v;loader.setParser(img, el('#a'));loader.load('test.png');// mdLoaderconst md = (v, el) =&gt; el.innerHTML = parserMD(v);loader.setParser(md, el('#b'));loader.load('README.md'); 클래스로 정의하면 코드화되고 코드를 건드려야 하는데 그에 비해서 커맨드객체가 보다 유연하기 때문에 인자를 여러개 보내거나 함수를 다양하게 보낼 수 있어서 그 모든 경우의 수를 클래스로 지정하지 않아도 사용 할 수 있게 되는 것이다. 상태를 통합으로 관리해주는 커맨드객체와 실행기인 인보커함수를 저장하는 방식으로 만들었기 때문에 다양한 함수와 인자가 몇개씩 있는 여러 가지 조합들도 다 대응 할 수 있게 된다. 4. 실행시점의 선택 위임 바로 위 코드에서 커맨드패턴을 사용하더라도 img나 md를 사용하는 상황에 따른 분기를 처리해야 됨이 제거 된것은 아니다. 이를 해결하기 위해서 우회적인 방법을 사용하게 된다. 모든 경우의 수를 알 수 있다면 경우의 수의 연산은 값 테이블로 바꿀 수 있다. 백가지 경우라면 백가지 경우를 모두 테이블에 넣어 놓고 키를 넣으면 값이 나오는 형태로 바꿀 수 있다. 이를 라우터라고 한다. 라우터는 필연적으로 라우터테이블을 데리고 다니는데 이는 선택이나 연산을 제거하고 경우의 수를 넣음으로써 대응하는 결과가 나오도록 만들어주고, 이 테이블을 이용해서 내가 원하는 결과를 출력해 주는 매칭기가 라우터 이다. 라우터는 호스트의 if의 분기는 제거 할 수 없으니까 테이블 형태로 바꿔서 관리를 편하게 해주는 차선책을 선택한 것이다. 123456789101112131415const Loader = class &#123; constructor(id, repo) &#123; this._git = new Github(id, repo); this._router = new Map; &#125; add(ext, f, ...arg) &#123; ext.split(',').forEach( v =&gt; this._router.set(v, [f, ...arg])); &#125; load(v) &#123; const ext = this._v.split('.').pop(); if(!this._router.has(ext)) return; this._git.setParser(...this._router.get(ext)); this._git.load(v); &#125;&#125;; Loader 를 통해 if문 처리를 값만 계속 추가해서 처리 할 수 있는 형태로 변환하였다. 케이스가 늘어나도 if else 를 늘릴 필요 없이 값만 추가하면 되는 방식이다. if문이 값으로 변환된 것이다. 디자인패턴의 원리 중 하나는 문을 제거해서 값으로 바꿀 수 있는 객체화 시키는 것이다. 값으로 바꿔야지만 코드를 고치지 않고 확장이 가능하다. 문이 되면 우리가 타이핑을 쳐서 저장해야만 한다. 이를 활용해서 우리는 더 많은 확장자를 지원하도록 코드를 지연시켜서 작성 할 수도 있고, 업그레이드를 할 수도 있고, 플러그인을 추가 할 수도 있고, 개발자의 코드를 안전하게 위임 할 수 있게 된다. 이로써 진짜 병렬적인 업무를 가능하게 해준다. 12345678const loader = new Loader('hanwong', 'codespitz');// 발생가능한 경우의 수를 값으로 기술loader.add('jpg, png, gif', img, el('#a'));loader.add('md', md, el('#b'));loader.load('xx.png');loader.load('xx.md'); 결론은 실행시점의 선택 위임을 통해서 발생가능한 경우의 수를 값으로 기술하게 하는 것이다. 소유위임을 통해서 코드의 분산을 정적으로 정의하지 않고 경우의 수에 따라 동적으로 정의 할 수 있는 발판을 마련했다면, if문에 대한 분기는 문을 계속해서 값으로 바꿔주는 것으로써 대체한다. 디자인패턴 중 if문을 제거하기 위한 패턴으로 템플릿메소드패턴, 전략패턴, 더 나아가서 상태패턴이라는 것이 있다. for문을 제거하기 위한 패턴으로는 이터레이터, 컴포지트, 비지터 패턴이 있다. for문을 돌다가 if문을 하고 싶다면? 데코레이터, 체인오브리스판서빌리티 패턴을 활용하여 문들을 제거하고 값으로 바꿀 수 있게 된다. 절차적인 부분을 감싸서 값으로 만들고 싶다면? 커맨드패턴 또는 미디에이터 여러 개의 객체들을 조립하는 과정들이 있다면? 빌더패턴, 파스드패턴 결국엔 문으로 구성하던 것들을 값으로 바꿔서 대체하고 싶은 것이다. 정리…상태에 대한 분기는 사라지지 않는다. 그 분기가 필요해서 태어났기 때문에~ 정의 시점에 제거하는 방법은? 분기 수 만큼 객체를 만들고 실행시점에 경우의 수를 공급한다. 실행시점으로 분기를 옮길 때의 장단점 장점 정의 시점에 모든 경우를 몰라도 됨 정의 시점에 그 경우를 처리하는 방법도 몰라도 됨 일정한 통제 범위 내에서 확장 가능한 알고리즘 설계 가능 단점 실행 시점에 모든 경우를 반드시 기술해야 함 설정을 빼먹으면 런타임에 프로그램이 죽게된다. 이것에 대해서는 외부에서 더블체크를 해야한다. 실행 시점마다 알고리즘의 안정성을 담보해야 함 매 호스트코드마다 안정성을 따로 담보해야 함 이러한 장단점을 기반으로 프로그램의 안정도와 확정성에 대한 밸런스를 잡아주는 것이 어렵다. 런타임 안정성이 담보되지 않기 때문에 이 단점을 커버하는 다양한 추가 패턴을 사용하게 된다. 런타임에 작성해야 할 코드들을 객체로 묶어서 관리하여 안정화 시킨다. 팩토리패턴, 빌더패턴 패턴이 패턴을 부르게 된다. 패턴이 다른 패턴을 이용해서 자기 패턴의 약점을 보완하지 않으면 약점이 커지고 불안정해진다. 자신의 불안정성을 감추기 위해서 자신의 불안한 파트를 커버하는 커운터 패턴을 다시 사용하게 된다. 이 의미를 이해하지 못하면 패턴을 그냥 번복만 할 뿐이지 안정성이 높아지지 않는다. 어떤 패턴을 쓸 때 어떤 패턴으로 카운터를 걸어서 안정성을 높여야 하는지 이해해야 한다. video, p img { width: 100%; box-shadow:0 10px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://hanwong.github.io/categories/Design-Pattern/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://hanwong.github.io/tags/OOP/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://hanwong.github.io/tags/Design-Pattern/"},{"name":"Template Method Pattern","slug":"Template-Method-Pattern","permalink":"http://hanwong.github.io/tags/Template-Method-Pattern/"},{"name":"Strategy Pattern","slug":"Strategy-Pattern","permalink":"http://hanwong.github.io/tags/Strategy-Pattern/"},{"name":"Command Pattern","slug":"Command-Pattern","permalink":"http://hanwong.github.io/tags/Command-Pattern/"},{"name":"Router Table","slug":"Router-Table","permalink":"http://hanwong.github.io/tags/Router-Table/"},{"name":"디자인패턴","slug":"디자인패턴","permalink":"http://hanwong.github.io/tags/디자인패턴/"},{"name":"탬플릿메소드패턴","slug":"탬플릿메소드패턴","permalink":"http://hanwong.github.io/tags/탬플릿메소드패턴/"},{"name":"전략패턴","slug":"전략패턴","permalink":"http://hanwong.github.io/tags/전략패턴/"},{"name":"커맨드패턴","slug":"커맨드패턴","permalink":"http://hanwong.github.io/tags/커맨드패턴/"},{"name":"라우터테이블","slug":"라우터테이블","permalink":"http://hanwong.github.io/tags/라우터테이블/"}]},{"title":"VueJS | Vuex Unit Test (1)","slug":"vuex-actions-unit-test","date":"2017-09-22T15:00:00.000Z","updated":"2017-09-24T13:14:25.000Z","comments":true,"path":"2017/09/23/vuex-actions-unit-test/","link":"","permalink":"http://hanwong.github.io/2017/09/23/vuex-actions-unit-test/","excerpt":"Axios를 활용해서 API 호출을 담당하는 Action들의 Unit Test에 대해 다루는 글입니다.","text":"Axios를 활용해서 API 호출을 담당하는 Action들의 Unit Test에 대해 다루는 글입니다. 해보고싶다 Unit Test원칙적으로 TDD를 하고자 하면 먼저 테스트 코드를 작성 한 후에 그에 맞춰서 코드를 작성해 나가는것이라고 알고 있지만 막상 일정을 타이트하게 잡고 개발을 시작하게 되면 TDD라는 것은 까마득하게 잊어 버리게 되는것 같습니다.그러나 마무리가 되어갈 쯤 TDD 해야 하나 하는 생각이 항상 스쳐지나가고 한번 해봐야지 해봐야지 하다가 매번 미루고 그냥 지나갔었던것 같습니다. 요번에 마침 여유 아닌 여유가 생겨서 TDD를 한번 시도해보았습니다. 이미 개발을 많이 해놓은지라 컴포넌트 단위의 이벤트를 처리하는 것을 테스트 하는 것은 시간이 많이 걸릴것 같고 API 호출을 담당하는 Action들을 조금이라도 Unit Test를 해보면 좋을것 같다는 생각이 들어서 Action Unit Test를 찾아보기 시작했습니다.실제적인 Vuejs의 Unit Test에 대한 지식은 전무했던지라 하나 하나 검색해보았습니다. 처음에 생각 했을 때는 API 호출하는 기능들을 테스트하려면 DB에 뭔가 더미 데이터가 박혀 있어야 하나 생각 했었는데 이미 TDD 를 하고 계신 백엔드를 담당하시는 팀장님께서 백엔드에서는 호출 하지 않고 Mock을 만들어서 테스트를 한다고 하시더군요…Mock이라는게 있는지도 몰랐었는데 axios 관련해서도 mock을 검색하니 바로 나오더 군요. axios-mock-adapter라는 것이었습니다. 그런데 Unit Test를 시작하지도 않았던 상태였던지라… 설명을 봐도 어떤 상황에 써야 하는것인지 감이 안오더군요… 이 모듈에 대해서는 제일 마지막에 다루게 될것 같습니다. 아무튼 서두가 많이 길어졌는데 TDD를 하기 위해서는 얕은 지식으로 Test코드를 먼저 구현한 다음에 실제 코딩을 하는것이라고 알고 있었는데 역시 그래야 하는것을 몸으로 부딪히며 느꼈습니다. 지금부터 설명드리려는 과정은 하나의 Action을 테스트 해보기 위해서 기존의 코드를 수정하는 과정들까지 모두 설명드리려고 합니다. 기존 코드 수정하기1. Action 분리하기제가 개발한 환경은 vue-cli로 기본 환경을 설정하였고 store폴더에 vuex 관련 설정을 하였었습니다.아래 코드와 같이 기능에 따라서 module들을 분리해서 구성을 했었고 하나의 module 안에 state, mutations, actions, getters를 모두 담은 구조로 개발해놓은 상태였었습니다. store/modules/project.js1234567891011const state = &#123;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123; state, mutations, actions, getters&#125; 이런 형태로요 그런데…Action을 Unit Test하는 방법을 찾아보니 Action들을 테스트하기 위해서는 모듈에서 별도의 파일로 분리되어 있어야 테스트 코드에서 Action들만 inject-loader로 삽입하여 활용하기가 용이한것을 알 수 있었습니다. 그래서 아래 구조와 같이 하나의 모듈은 한 폴더에 담고 actions 파일만 따로 분리하였습니다. 파일을 분리하는 방법은 각자가 사용하기 편한 스타일로 하면 될것 같습니다. 12345store└── modules └── project ├── index.js └── actions.js store/modules/project/index.js123456789101112import actions from './actions'const state = &#123;&#125;const mutations = &#123;&#125;const getters = &#123;&#125;export default &#123; state, mutations, actions, getters&#125; store/modules/project/actions.js12345678910111213export default &#123; // 예로 Test 해볼 action 입니다. setProject (&#123;commit&#125;, pid) &#123; axios.get(`project/$&#123;pid&#125;`) .then((res) =&gt; &#123; commit('SET_PROJECT', res.data.project) &#125;) .catch((error) =&gt; &#123; console.log(error) &#125;) &#125;, // 그외 action 함수들&#125; 2. API 함수화 하기여기까지는 뭐 모듈 파일들이 그리 많지 않으니 이렇게 구조 바꿔도 괜찮겠구나 생각했습니다…또 그런데… 각 Action들에 심어져 있는 axios로 API를 호출하는 부분들을 별도로 함수화 해서 정리해주는 것이 필요했습니다.이부분에서 느꼈던 것이 아직 개발 경험이 많이 없다 보니 구글에서 검색하면 나오는 자료들을 바탕으로 개발하며 일하다보니 내가 잘하고 있는 건가 하는 의문이 있었는데 그렇지 못하다는 것을 알 수 있었습니다. 그냥 봐왔던 예제들이 거의다 axios.get(), axios.post() 요런 형태들로 직접 호출하는것만 봐왔지 이부분을 분리해서 관리할 수 있겠구나 하는 생각은 해보지 못했었습니다. Action을 Unit Test하는 자료들을 보니 대부분이 API 호출 부분을 분리해서 관리할 수 있구나 하는 것을 알 수 있었습니다.그래서 Action들 내의 axios 를 활용한 API 호출 관련 코드들을 아래와 같이 별도의 함수로 분리하였습니다. 1234567api└── index.jsstore└── modules └── project ├── index.js └── actions.js api/index.js12345import axios from 'axios'export const getProject = (pid) =&gt; &#123; return axios.get(`project/$&#123;pid&#125;`)&#125; store/modules/project/actions.js12345678910111213import * as api from '@/api'export default &#123; setProject (&#123;commit&#125;, pid) &#123; api.getProject(pid) // 이렇게 변경하였습니다. .then((res) =&gt; &#123; commit('SET_PROJECT', res.data.project) &#125;) .catch((error) =&gt; &#123; console.log(error) &#125;) &#125;,&#125; 이제 Unit Test를 해봅시다위에 설명드린 것과 같이 코드를 구성해놓으면 이제 하나의 Action을 Unit Test 해볼 수 있습니다. api들을 모두 함수화해 놓으면 다른 Action들도 테스트가 가능할것이구요. 관련문서: Vuex Testing 1. Action helper먼저 문서를 확인해보면 비동기 Action을 테스트하기 위해서는 helper 함수가 필요합니다. helper 함수는 대부분 Action을 사용할 때 어떤 작업을 마치고 난 이후에 Mutation으로 State에 값을 저장하는 일들을 하기 때문에 실행할 Mutation을 인자로 받아서 실제 Action처럼 동작할 수 있도록 해주는 부분 입니다. 저는 아래와 같은 구조로 구성해놓았습니다. 1234567891011121314api└── index.jsstore└── modules └── project ├── index.js └── actions.jstest└── unit ├── helpers │ ├── index.js │ └── api.js └── spcecs └── actions.spec.js test/unit/helpers/index.js1234567891011121314151617181920212223242526272829303132// 예상되는 변이와 함께 테스팅 액션을 도와주는 헬퍼export const testAction = (action, payload, state, expectedMutations, done) =&gt; &#123; let count = 0 // 모의 커밋 const commit = (type, payload) =&gt; &#123; const mutation = expectedMutations[count] try &#123; expect(mutation.type).to.equal(type) if (payload) &#123; expect(mutation.payload).to.deep.equal(payload) &#125; &#125; catch (error) &#123; done(error) &#125; count++ if (count &gt;= expectedMutations.length) &#123; done() &#125; &#125; // 모의 저장소와 전달인자로 액션을 부릅니다. action(&#123; commit, state &#125;, payload) // 디스패치된 변이가 없는지 확인 if (expectedMutations.length === 0) &#123; expect(count).to.equal(0) done() &#125;&#125; 2. Mock 환경 구성하기그리고 api 실행을 할 때 일정한 요청으로 하더라도 DB에 값이 변한다면 응답 값이 바뀔수도 있기 때문에 api 요청에 대한 일정한 응답을 할 수 있도록 Mock 환경을 구성해주어야 합니다. 관련문서:axios-mock-adapter 여기에서 아래와 같이 axios-mock-adapter를 활용합니다. axios-mock-adapter 자세한 활용 방법은 위에 링크를 확인해보시기 바랍니다. test/unit/helpers/api.js12345678import axios from 'axios'const MockAdapter = require('axios-mock-adapter')const mock = new MockAdapter(axios)mock.onGet('project/1').reply(200, &#123; data: &#123; project: &#123;id:1, name: 'test1'&#125; &#125;&#125;) 3. 진짜 막판왕 테스트 코드…여기까지 모든 환경구성이 완료가 되었으면 Action을 Unit Test를 하기 위한 준비가 끝났습니다. 이제 테스트 코드를 작성하면 됩니다. test/unit/specs/actions.spec.js12345678910111213141516171819202122232425262728293031import &#123; testAction &#125; from '../helpers'import axios from 'axios'// Mock Adapterrequire('../helpers/api')// 기존 store 소스 코드를 수정한 이유 Action만 Inject 하기 위해서...const actionsInjector = require('inject-loader!@/store/modules/project/actions')// axios를 함수화한 이유 axios를 사용하기 위해서...const actions = actionsInjector(&#123; '@/api': &#123; getProject () &#123; return axios.get(`project/1`) &#125; &#125;&#125;)// 대망의 테스트 코드... describe('actions', () =&gt; &#123; it('setProject', (done) =&gt; &#123; testAction(actions.default.setProject, null, &#123;&#125;, [ &#123; type: 'SET_PROJECT', payload: &#123; data: &#123; project: &#123;id:1, name: 'test1'&#125; &#125; &#125; &#125; ], done) &#125;)&#125;) 테스트 코드에서 위에 설정된 부분들을 구성하기 위해서 앞서 설명드린 환경 구성을 하였습니다.그리고 테스트 코드를 작성할 때는 헬퍼 함수인 testAction을 활용합니다. 테스트 할 Action, Action에 전달하는 값들, State, 사용될 Mutation과 예상되는 결과 값을 인자로 넣어주면 테스트 코드가 완료 됩니다.그러면 대망의 테스트 결과를 확인하실수 있을 것입니다. 이 코드는 정말 간단한 코드라서 다른 좀 더 복잡한 코드들을 테스트하는 부분은 저도 앞으로 좀 더 공부해봐야 할것 같습니다. 그리고 Action 내부에서 다른 Action을 dispatch하는 경우를 다음 편에서 다뤄볼까 합니다. video, p img { width: 100%; box-shadow:0 10px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://hanwong.github.io/categories/VueJS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://hanwong.github.io/tags/vue/"},{"name":"vuejs","slug":"vuejs","permalink":"http://hanwong.github.io/tags/vuejs/"},{"name":"vuex","slug":"vuex","permalink":"http://hanwong.github.io/tags/vuex/"},{"name":"actions","slug":"actions","permalink":"http://hanwong.github.io/tags/actions/"},{"name":"axios","slug":"axios","permalink":"http://hanwong.github.io/tags/axios/"},{"name":"unit","slug":"unit","permalink":"http://hanwong.github.io/tags/unit/"},{"name":"test","slug":"test","permalink":"http://hanwong.github.io/tags/test/"},{"name":"unit-test","slug":"unit-test","permalink":"http://hanwong.github.io/tags/unit-test/"},{"name":"mock","slug":"mock","permalink":"http://hanwong.github.io/tags/mock/"},{"name":"TDD","slug":"TDD","permalink":"http://hanwong.github.io/tags/TDD/"},{"name":"axios-mock-adapter","slug":"axios-mock-adapter","permalink":"http://hanwong.github.io/tags/axios-mock-adapter/"}]},{"title":"VueJS | Stock-Trader Project Tutorial (4)","slug":"vue-stock-trader-04","date":"2017-05-19T15:00:00.000Z","updated":"2017-09-21T13:35:22.000Z","comments":true,"path":"2017/05/20/vue-stock-trader-04/","link":"","permalink":"http://hanwong.github.io/2017/05/20/vue-stock-trader-04/","excerpt":"이 포스팅은 Max의 Vuejs 강좌 내용을 정리한 것이고, VueJS의 개념을 익히고 연습해보기 위한 튜토리얼을 다룬 글 입니다. 이번 포스팅은 Stock-Trader Project Tutorial의 마지막 편입니다.Filter, Animation 을 추가하고 vue-resource를 활용해 Firebase와 연결해서 데이터를 저장하고 불러오는 기능까지 구현하여 이번 튜토리얼을 마치려고 합니다.","text":"이 포스팅은 Max의 Vuejs 강좌 내용을 정리한 것이고, VueJS의 개념을 익히고 연습해보기 위한 튜토리얼을 다룬 글 입니다. 이번 포스팅은 Stock-Trader Project Tutorial의 마지막 편입니다.Filter, Animation 을 추가하고 vue-resource를 활용해 Firebase와 연결해서 데이터를 저장하고 불러오는 기능까지 구현하여 이번 튜토리얼을 마치려고 합니다. 1. Filter 기능 추가 하기1. funds 값 표시하기 Filter 기능을 적용하기 위해 funds state를 표시할 요소를 Header.vue와 Home.vue에 추가합니다. src/components/Header.vue1234567891011121314151617181920212223&lt;template&gt;&lt;!--...생략...--&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;router-link to=\"/portfolio\" activeClass=\"active\" tag=\"li\"&gt;&lt;a&gt;Portfolio&lt;/a&gt;&lt;/router-link&gt; &lt;router-link to=\"/stocks\" activeClass=\"active\" tag=\"li\"&gt;&lt;a&gt;Stocks&lt;/a&gt;&lt;/router-link&gt; &lt;/ul&gt; &lt;!-- Funds 요소 추가 Start --&gt; &lt;strong class=\"navbar-text navbar-right\"&gt;Funds: &#123;&#123; funds &#125;&#125;&lt;/strong&gt; &lt;!-- Funds 요소 추가 End --&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\" @click=\"endDay\"&gt;End Day&lt;/a&gt;&lt;/li&gt;&lt;!--...생략...--&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; funds() &#123; return this.$store.getters.funds; &#125; &#125; &#125;&lt;/script&gt; src/components/Home.vue12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;h1&gt;Trade or View your Portfolio&lt;/h1&gt; &lt;h6&gt;You may Save &amp; Load your Data&lt;/h6&gt; &lt;h6&gt;Click on 'End Day' to begin a New Day!&lt;/h6&gt; &lt;hr&gt; &lt;p&gt;Your Funds: &#123;&#123; funds &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; funds() &#123; return this.$store.getters.funds; &#125; &#125; &#125;&lt;/script&gt; 2. filter 등록하기 main.js에 프로젝트 어디에서나 사용 할 수 있도록 filter를 등록해줍니다. 사용할 filter의 이름은 currency이고 변수 앞에 $ 표시를 붙여주는 단순한 filter입니다. src/main.js123456789//...생략...Vue.use(VueRouter);Vue.filter('currency', value =&gt; &#123; return '$' + value.toLocaleString();&#125;);//...생략... 3. filter 사용하기 1번 과정에서 Header.vue와 Home.vue에 추가한 funds 요소 안에 아래 코드와 같이 파이프라인 뒤에 사용할 필터 이름을 추가해줍니다. src/components/Header.vue123&lt;!--...생략...--&gt; &lt;strong class=\"navbar-text navbar-right\"&gt;Funds: &#123;&#123; funds | currency &#125;&#125;&lt;/strong&gt;&lt;!--...생략...--&gt; src/components/Home.vue123&lt;!--...생략...--&gt; &lt;p&gt;Your Funds: &#123;&#123; funds | currency &#125;&#125;&lt;/p&gt;&lt;!--...생략...--&gt; 2. 주문량 제한하는 기능 추가하기 Stocks 페이지나 Portfolio 페이지에서 각 Stock 컴포넌트를 통해 사거나 파는 액션을 실행하면서 funds와 order주문량에 따라서 가능한 범위 내에서만 주문할 수 있도록 button 요소에 제한하는 기능을 추가해봅니다. insufficientFunds, insufficientQuantity 메소드를 만들고 button과 input요소에 추가해줍니다. 상태가 변했을 때 스타일이 변할수 있도록 설정한 클래스를 &lt;style&gt; 에 추가해줍니다. &lt;style scpoed&gt; 와 같이 style 태그 안에 scoped라는 속성을 추가하면 해당 컴포넌트의 요소들에만 영향을 주고 다른 컴포넌트의 요소들에는 전혀 영향이 가지 않도록 할 수 있습니다. src/components/stocks/Stock.vue1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt;&lt;!--...생략...--&gt; &lt;div class=\"pull-left\"&gt; &lt;input type=\"number\" class=\"form-control\" placeholder=\"Quantity\" v-model.number=\"quantity\" :class=\"&#123;danger: insufficientFunds&#125;\" &gt; &lt;/div&gt; &lt;div class=\"pull-right\"&gt; &lt;button class=\"btn btn-success\" @click=\"buyStock\" :disabled=\"insufficientFunds || quantity &lt;= 0 || !Number.isInteger(quantity)\" &gt;&#123;&#123; insufficientFunds ? 'Too Much' : 'Buy'&#125;&#125; &lt;/button&gt; &lt;/div&gt;&lt;!--...생략...--&gt;&lt;/template&gt;&lt;style scpoed&gt; .danger, .danger:focus &#123; border: 1px solid red; &#125;&lt;/style&gt;&lt;script&gt;//...생략... computed: &#123; funds() &#123; return this.$store.getters.funds; &#125;, insufficientFunds() &#123; return this.quantity * this.propStock.price &gt; this.funds; &#125; &#125;,//...생략...&lt;/script&gt; src/components/portfolio/Stock.vue1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt;&lt;!--...생략...--&gt; &lt;div class=\"pull-left\"&gt; &lt;input type=\"number\" class=\"form-control\" placeholder=\"Quantity\" v-model.number=\"quantity\" :class=\"&#123;danger: insufficientQuantity&#125;\" &gt; &lt;/div&gt; &lt;div class=\"pull-right\"&gt; &lt;button class=\"btn btn-success\" @click=\"sellStock\" :disabled=\"insufficientQuantity || quantity &lt;= 0 || !Number.isInteger(quantity)\" &gt;&#123;&#123;insufficientQuantity ? 'Too Much' : 'Sell'&#125;&#125; &lt;/button&gt; &lt;/div&gt;&lt;!--...생략...--&gt;&lt;/template&gt;&lt;style scpoed&gt; .danger, .danger:focus &#123; border: 1px solid red; &#125;&lt;/style&gt;&lt;script&gt;//...생략... computed: &#123; funds() &#123; return this.$store.getters.funds; &#125;, insufficientQuantity() &#123; return this.quantity &gt; this.propStock.quantity; &#125; &#125;,//...생략...&lt;/script&gt; 3. End Day 랜덤 시세 변경 기능 추가하기1. RND_STOCKS mutation 만들기 이전 포스팅에서는 비어 두웠던 RND_STOCKS mutation에 그냥 적당한 선에서 각 stock의 price 값이 랜덤하게 변경할 수 있도록 기능을 추가해 줍니다. src/store/modules/stocks.js1234567// ...생략... 'RND_STOCKS' (state) &#123; state.stocks.forEach( stock =&gt; &#123; stock.price = Math.round(stock.price * (1 + Math.random() - 0.5)); &#125;); &#125;// ...생략... 2. endDay 기능 추가하기 RND_STOCKS mutation을 실행하는 action인 randomizeStocks을 활용해서 클릭했을 때 실행 할 메소드를 추가해줍니다. src/components/Header.vue1234567891011121314151617181920212223242526&lt;template&gt;&lt;!--...생략...--&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\" @click=\"endDay\"&gt;End Day&lt;/a&gt;&lt;/li&gt;&lt;!--...생략...--&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapActions&#125; from 'vuex'; export default &#123; computed: &#123; funds() &#123; return this.$store.getters.funds; &#125; &#125;, methods: &#123; ...mapActions([ 'randomizeStocks' ]), endDay() &#123; this.randomizeStocks(); &#125; &#125; &#125;&lt;/script&gt; 4. Animation 효과 추가하기 VueJS에서는 Animation 효과를 좀 더 명확하고 구조적으로 적용할 수 있는 transition이라는 요소가 있습니다. 자세한 API는 이 링크를 참조해주세요. Transition 먼저 Animation 효과를 적용하기 위해서는 적용할 요소를 transition 요소로 감싸주고 name과 mode를 지정해줍니다. 그러면 지정된 transition요소의 name 뒤로 -enter-active, -leave-active, 등의 포스트픽스가 붙는 이름의 클래스 안에 각 상태에 맞는 효과를 추가해줍니다. 관련된 보다 자세한 사항들도 위 링크를 참주해주세요. src/App.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div class=\"container\"&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;!--여기에 animation 이 적용되는 transition 영역을 만들어줍니다.--&gt; &lt;transition name=\"slide\" mode=\"out-in\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--...생략...--&gt;&lt;style&gt; body &#123; padding: 30px; &#125; .slide-enter-active &#123; animation: slide-in 200ms ease-out forwards; &#125; .slide-leave-active &#123; animation: slide-out 200ms ease-out forwards; &#125; @keyframes slide-in &#123; from &#123; transform: translateY(-30px); opacity: 0; &#125; to &#123; transform: translateY(0); opacity: 1; &#125; &#125; @keyframes slide-out &#123; from &#123; transform: translateY(0px); opacity: 1; &#125; to &#123; transform: translateY(-30px); opacity: 0; &#125; &#125;&lt;/style&gt; 위의 설정을 완료하면 이와 같은 Animation 효과를 확인하실 수 있습니다. 5. Firebase에 데이타 저장하고 불러오기마지막으로 대망의 Firebase와 연결하기 입니다.vue-resource 설정을 추가하기 이전에 save, load 기능을 사용할 dropdown 요소를 열었다 닫았다 할 수 있도록 간단히 세팅해줍니다. src/components/Header.vue1234567891011121314151617&lt;template&gt;&lt;!--...생략...--&gt; &lt;li class=\"dropdown\" :class=\"&#123;open: isDropDownOpen&#125;\" @click=\"isDropDownOpen = !isDropDownOpen\"&gt;&lt;!--...생략...--&gt;&lt;/template&gt;&lt;script&gt;//...생략... data() &#123; return &#123; isDropDownOpen: false &#125; &#125;,//...생략...&lt;/script&gt; 1. Firebase 초기 세팅하기먼저 Firebase 계정을 생성하고 프로젝트 초기 세팅을 하는 부분은 firebase 초기 세팅 이곳을 참고해주시기 바랍니다. 2. main.js에 vue-resource와 Firebase 추가하기 가장 먼저 터미널에서 npm install --save vue-resource 를 실행하여 vue-resource 모듈을 설치합니다. 그리고 아래 코드와 같이 main.js에 vue-resource 모듈을 추가하고 DB의 root 주소를 등록해주면 기본 설정은 모두 완료된것입니다. 참 간단하죠~^^ src/main.js1234567//...생략...import VueResource from 'vue-resource';//...생략...Vue.use(VueResource);Vue.http.options.root = 'https://본인 Firebase DB 주소';//...생략... 3. 데이타 저장하기 saveData 메소드에서 DB에 현재 저장할 데이터들을 추가해줍니다. vue-resource의 API는 this.$http.put 와 같이 this.$http 뒤에 필요한 메소드를 붙혀서 사용할 수 있습니다. put메소드를 사용할 때는 data.json 테이블이름.데이타타입 과 같이 데이타를 저장할 위치와 형태를 결정해주고 추가할 데이타를 변수로 넘겨주면 됩니다. dropdown-menu 에서 Save Data 메뉴에 saveData 메소드를 추가해줍니다. src/components/Header.vue1234567891011121314151617181920212223&lt;template&gt;&lt;!--...생략...--&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\" @click=\"saveData\"&gt;Save Data&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" @click=\"\"&gt;Load Data&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;!--...생략...--&gt;&lt;/template&gt;&lt;script&gt;//...생략... methods: &#123;//...생략... saveData() &#123; const data = &#123; funds: this.$store.getters.funds, stockPortfolio: this.$store.getters.stockPortfolio, stocks: this.$store.getters.stocks &#125;; this.$http.put('data.json', data); &#125;,//...생략...&lt;/script&gt; 4. 데이타 불러오기 초기에 SET_STOCKS mutation으로 고정된 초기값으로 데이타를 불러오는 부분은 있었지만 새로 생성된 portfolio 데이타를 불러와서 초기 설정 해주는 부분이 없었습니다. 그래서 portfolio.js 모듈 안에 portfolio 데이타를 설정해주는 SET_PORTFOLIO mutation을 추가해줍니다. src/store/modules/portfolio.js123456// ...생략... 'SET_PORTFOLIO' (state, portfolio) &#123; state.funds = portfolio.funds; state.stocks = portfolio.stockPortfolio ? portfolio.stockPortfolio : []; &#125;// ...생략... 이 프로젝트의 DB에서 데이타를 불러오는 것은 Stocks, Portfolio 와 관련된 모든 데이타를 불러오는 것이기 때문에 어디서나 공통으로 사용하는 loadData action을 따로 생성해줍니다. 이렇게 공통적으로 사용해야 하는 기능은 action만 따로 모아서 등록을 해놓을 수도 있습니다. 컴포넌트 환경과는 다르게 JS에서 vue-resource를 사용할 때는 Vue인스턴스를 활용해서 Vue.http 뒤에 메소드를 호출하는 방식으로 사용합니다. loadData action 에서는 저장하기에서 데이타를 저장했던 위치와 형태 그대로 get 메소드로 데이타를 호출하고 데이타를 각 컴포넌트에서 사용하는 형태로 변환하여 전달해줍니다. src/store/actions.js123456789101112131415161718192021import Vue from 'vue';export const loadData = (&#123;commit&#125;) =&gt; &#123; Vue.http.get('data.json') .then( response =&gt; response.json() ) .then( data =&gt; &#123; if(data) &#123; const stocks = data.stocks; const funds = data.funds; const stockPortfolio = data.stockPortfolio; const portfolio = &#123; stockPortfolio, funds &#125;; commit('SET_STOCKS', stocks); commit('SET_PORTFOLIO', portfolio); &#125; &#125;);&#125;; 그리고 생상한 actions.js는 store.js에 추가해줍니다. src/store/store.js123456789101112// ...생략...import * as actions from './actions'; // actions.js 추가를 위한분Vue.use(Vuex);export default new Vuex.Store(&#123; actions, // actions.js 추가를 위한분부분 modules: &#123; stocks, portfolio &#125;&#125;); 마지막으로 등록된 loadData action을 Header 컴포넌트에 추가해줍니다. 아래 코드에서 기존 코드와 조금 바뀐점은 mapActions 헬퍼함수 안에 action의 key 값을 설정해주는 부분입니다. 기존 코드에서는 ...mapActions([]) 배열 안에 필요한 action을 등록해주었었는데 그래서 key 값을 따로 설정해줄 수는 없었습니다. 프로젝트에 기능이 점점 추가되고 action 들이 많아지기 시작하면 이름들이 중복될 수도 있고 헷갈릴수도 있기 때문에 ...mapActions({}) 처럼 객체를 사용하면 등록한 action의 key값을 별도로 정의할수도 있습니다. 그리고 해당 컴포넌트 내에서는 그 key로 해당 action을 사용하면 됩니다. src/components/Header.vue123456789101112131415161718192021222324252627282930313233&lt;template&gt;&lt;!--...생략...--&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\" @click=\"saveData\"&gt;Save Data&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" @click=\"loadData\"&gt;Load Data&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;!--...생략...--&gt;&lt;/template&gt;&lt;script&gt;// ...생략... methods: &#123; ...mapActions(&#123; randomizeStocks: 'randomizeStocks', fetchData: 'loadData' &#125;), endDay() &#123; this.randomizeStocks(); &#125;, saveData() &#123; const data = &#123; funds: this.$store.getters.funds, stockPortfolio: this.$store.getters.stockPortfolio, stocks: this.$store.getters.stocks &#125;; this.$http.put('data.json', data); &#125;, loadData() &#123; this.fetchData(); &#125; &#125; &#125;&lt;/script&gt; 5. 페이지 접속시 데이타 불러오기 Load Data 버튼이 있기는 하지만 앱에 접속 했을 때 바로 이전 데이타를 불러오는 것이 자연스럽기 때문에 앱 접속시 이전 데이타를 바로 불러올 수 있도록 App.vue 에 loadData action을 추가해줍니다. VueJS는 컴포넌트의 script 영역에서 created 라이프사이클 훅을 사용해서 요소들이 렌더링이 되기 전에 미리 데이타를 로딩 해놓을 수 있습니다. created 외에도 다양한 라이프사이클을 활용 할 수 있습니다. src/App.vue1234567891011121314151617181920&lt;!--...생략...--&gt;&lt;script&gt; import &#123;mapActions&#125; from 'vuex'; import Header from './components/Header.vue'; export default &#123; methods: &#123; ...mapActions(&#123; fetchData: 'loadData' &#125;) &#125;, components: &#123; 'appHeader': Header &#125;, created() &#123; this.fetchData(); &#125; &#125;&lt;/script&gt;&lt;!--...생략...--&gt; 기본적인 구조를 잡고 컴포넌트를 만드는 것 부터 vue-router, vuex, vue-resource 까지 VueJS 를 활용하여 SPA를 만드는 과정을 소개해보았습니다. 깊이 있는 내용은 많이 다루지 못했지만 전체적인 흐름으르 한번 체험해보면 VueJS를 학습하는데 조금 도움이 되지 않을까 싶어서 작성하기 시작한 포스팅이었습니다. 한분에게라도 도움이 되는 글이 되었다면 감사할것 같습니다. 좀 더 필요하신 부분이나 보완할 점이 있다면 댓글로 의견 남겨주시기 바랍니다. 감사합니다. git clone https://github.com/hanwong/vue-stock-trader.git 으로 프로젝트를 다운로드하고 git checkout step07 로 프로젝트의 최종 결과물을 확인 하실 수 있습니다. - 끝 - video, p img { width: 100%; box-shadow:0 10px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://hanwong.github.io/categories/VueJS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://hanwong.github.io/tags/vue/"},{"name":"vuejs","slug":"vuejs","permalink":"http://hanwong.github.io/tags/vuejs/"},{"name":"vue-resource","slug":"vue-resource","permalink":"http://hanwong.github.io/tags/vue-resource/"},{"name":"firebase","slug":"firebase","permalink":"http://hanwong.github.io/tags/firebase/"},{"name":"components","slug":"components","permalink":"http://hanwong.github.io/tags/components/"},{"name":"vue-router","slug":"vue-router","permalink":"http://hanwong.github.io/tags/vue-router/"},{"name":"vuex","slug":"vuex","permalink":"http://hanwong.github.io/tags/vuex/"},{"name":"tutorial","slug":"tutorial","permalink":"http://hanwong.github.io/tags/tutorial/"},{"name":"filter","slug":"filter","permalink":"http://hanwong.github.io/tags/filter/"},{"name":"animation","slug":"animation","permalink":"http://hanwong.github.io/tags/animation/"}]},{"title":"VueJS | Stock-Trader Project Tutorial (3)","slug":"vue-stock-trader-03","date":"2017-05-08T15:00:00.000Z","updated":"2017-09-21T13:35:51.000Z","comments":true,"path":"2017/05/09/vue-stock-trader-03/","link":"","permalink":"http://hanwong.github.io/2017/05/09/vue-stock-trader-03/","excerpt":"이 포스팅은 Max의 Vuejs 강좌 내용을 정리한 것이고, VueJS의 개념을 익히고 연습해보기 위한 튜토리얼을 다룬 글 입니다. 이전 포스팅에서는 vuex를 활용한 프로젝트의 상태 관리 환경 세팅과 vuex의 기본적인 사용방법에 대해서 알아 보았습니다. 이번 포스팅에서는 또 다른 컴포넌트의 상태 관리 설정을 추가하고 컴포넌트 간의 상태 변화에 따라 뷰가 갱신될 수 있도록 구현해보겠습니다.","text":"이 포스팅은 Max의 Vuejs 강좌 내용을 정리한 것이고, VueJS의 개념을 익히고 연습해보기 위한 튜토리얼을 다룬 글 입니다. 이전 포스팅에서는 vuex를 활용한 프로젝트의 상태 관리 환경 세팅과 vuex의 기본적인 사용방법에 대해서 알아 보았습니다. 이번 포스팅에서는 또 다른 컴포넌트의 상태 관리 설정을 추가하고 컴포넌트 간의 상태 변화에 따라 뷰가 갱신될 수 있도록 구현해보겠습니다. 1. Portfolio 컴포넌트 생성하기 기본적인 Portfolio 컴포넌트 구성은 이전 포스팅에서 Stocks 컴포넌트를 구성한 방법과 유사하므로 코드만 첨부하고 넘어가겠습니다. 하나만 설명드리자면 16라인에 v-model.number을 디렉티브를 사용한 부분이 있는데요, v-model을 그냥 사용하지 않고 뒷부분에 .number를 붙인 이유는 인풋요소에서 입력한 값에 따라 버튼에 속성을 조절하려고 했는데 인풋요소에서 넘어오는 값이 문자열로 넘어와서 유효성 체크가 되지 않아 숫자 형태로만 넘어가도록 해준것 입니다. 저도 v-model.number 이렇게 타입 지정까지 해주는 부분이 있는 줄 몰랐었는데 이부분의 오류를 해결하려다 보니 찾게 되었네요. src/components/portfolio/Stock.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div class=\"col-md-4 col-sm-6\"&gt; &lt;div class=\"panel panel-info\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt; &#123;&#123; propStock.name &#125;&#125; &lt;small&gt;(Price: &#123;&#123; propStock.price &#125;&#125; | Quantity: &#123;&#123;propStock.quantity &#125;&#125;)&lt;/small&gt; &lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"pull-left\"&gt; &lt;input type=\"number\" class=\"form-control\" placeholder=\"Quantity\" v-model.number=\"quantity\" &gt; &lt;/div&gt; &lt;div class=\"pull-right\"&gt; &lt;button class=\"btn btn-success\" @click=\"sellStock\" :disabled=\"quantity &lt;= 0 || !Number.isInteger(quantity)\" &gt;Sell&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: ['propStock'], data() &#123; return &#123; quantity: 0 &#125; &#125;, methods: &#123; sellStock() &#123; const order = &#123; stockId: this.propStock.id, stockPrice: this.propStock.price, quantity: this.quantity &#125;; &#125; &#125; &#125;&lt;/script&gt; src/components/portfolio/Portfolio.vue1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;app-stock v-for=\"stock in stocks\" :propStock=\"stock\"&gt;&lt;/app-stock&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Stock from './Stock.vue'; export default &#123; data() &#123; return &#123; // 이 단계에서는 임시적으로 data에 stocks를 추가하여 사용하고 portfolio store module 설정 후 수정할것 입니다. stocks: [] &#125; &#125;, components: &#123; appStock: Stock &#125; &#125;&lt;/script&gt; 2. Portfolio store module 생성하기src/store/modules/portfolio.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const state = &#123; funds: 10000, stocks: []&#125;;const mutations = &#123; 'BUY_STOCK'(state, &#123;stockId, quantity, stockPrice&#125;) &#123; const record = state.stocks.find(element =&gt; element.id === stockId); if(record) &#123; record.quantity += quantity; &#125; else &#123; state.stocks.push(&#123; id: stockId, quantity: quantity &#125;); &#125; state.funds -= stockPrice * quantity; &#125;, 'SELL_STOCK'(state, &#123;stockId, quantity, stockPrice&#125;) &#123; const record = state.stocks.find(element =&gt; element.id === stockId); if(record.quantity &gt; quantity) &#123; record.quantity -= quantity; &#125; else &#123; state.stocks.splice(state.stocks.indexOf(record), 1); &#125; state.funds += stockPrice * quantity; &#125;&#125;;const actions = &#123; sellStock(&#123;commit&#125;, order) &#123; commit('SELL_STOCK', order); &#125;&#125;;const getters = &#123; stockPortfolio(state, getters) &#123; return state.stocks.map(stock =&gt; &#123; const record = getters.stocks.find(element =&gt; element.id === stock.id); return &#123; id: stock.id, quantity: stock.quantity, name: record.name, price: record.price &#125; &#125;); &#125;, funds(state) &#123; return state.funds; &#125;&#125;;export default &#123; state, mutations, actions, getters&#125; 이번 글에서는 store 내의 각 요소에 대해서 조금 설명을 해보려고 합니다. 1. state - funds, stocks state에는 해당 컴포넌트 내/외부에서 사용할 데이타들을 미리 정의 해놓고 어디에서나 접근해서 사용 할 수 있게 해줍니다. funds는 stock을 구매 할 수 있는 전체 자산의 상태이고, stocks는 Stocks컴포넌트에서 구매한 stock의 상태입니다. 2. mutations - BUY_STOCK, SELL_STOCK muntation은 vuex에서 state를 변경 할 수 있는 유일한 방법입니다. 주로 action에서 commit함수를 통해 mutation을 호출하고 필요한 변수를 전달하는 방식으로 많이 사용합니다. 이전 포스팅을 다시 확인해보시면 BUY_STOCK을 호출하는 action은 stocks 모듈에 선언되어 있습니다. 해당 action을 사용하는 위치가 Stocks컴포넌트에 있기 때문에 그렇지요, 하지만 portfolio 모듈 안에 선언되어 있는 funds와 stacks state를 수정하기 위해서는 portfolio 내부의 mutation으로만 변경 할 수 있기 때문에 변경 할 state에 접근 가능한 mutation 사용해야 합니다. 3. actions - sellStock Portfolio 컴포넌트 내에서 state를 변경하는 기능을 하는 부분은 stocks 되파는 부분뿐 입니다. stocks를 되팔때 sellStock action에서는 클라이언트에서 팔고자하는 입력받은 수량만 SELL_STOCK mutation에 전달하고 전달 받은 데이타를 가지고 state를 변경하는 것은 mutation에서 실행하는 것입니다. 4. getters - stockPortfolio, funds getter를 사용하는 목적은 프로젝트 어디서나 state의 상태를 좀더 쉽게 조회하기 위함입니다. stockPortfolio getter에서는 파라메터로 getters 라는 것을 받고 있는데 이 파라메터를 사용하면 store에 등록되어 있는 모든 getter를 담고 있는 객체를 참조 할 수 있습니다. src/store/store.js1234567891011121314import Vue from 'vue';import Vuex from 'vuex';import stocks from './modules/stocks';import portfolio from './modules/portfolio';Vue.use(Vuex);export default new Vuex.Store(&#123; modules: &#123; stocks, portfolio &#125;&#125;); 5. store에 추가하기 모듈 생성이 완료 되었으면 store에 등록해줍니다. 이제 프로젝트 어디서나 등록한 portfolio 모듈을 사용 할 수 있습니다. 3. Portfolio 컴포넌트에 vuex 연결하기src/components/portfolio/Stock.vue12345678910111213141516171819202122232425262728293031...생략&lt;script&gt; // mapActions 헬퍼를 사용하기 위해 vuex를 임포트해줍니다. import &#123; mapActions &#125; from 'vuex'; export default &#123; props: ['propStock'], data() &#123; return &#123; quantity: 0 &#125; &#125;, methods: &#123; // mapActions 헬퍼를 사용하여 해당 컴포넌트의 속성에 맵핑해줍니다. ...mapActions(&#123; placeSellOrder: 'sellStock' &#125;), sellStock() &#123; const order = &#123; stockId: this.propStock.id, stockPrice: this.propStock.price, quantity: this.quantity &#125;; // sellStock action을 placeSellOrder라는 이름의 메소드로 사용합니다. this.placeSellOrder(order); this.quantity = 0; &#125; &#125; &#125;&lt;/script&gt; 이전 포스팅에서는 store를 사용할 때 this.$store.{...} 방법으로 일일이 찾아와서 사용을 했었는데 이번에는 헬퍼함수를 통해 설정해보았습니다. mapActions 헬퍼를 사용하여 store에 등록되어 있는 action중에 필요한 action만 불러와서 사용합니다. 컴포넌트 내에서는 mutation을 건드릴 일은 없습니다. 모든 동작은 action을 통해서 실행됩니다. ...mapActions과 같이 spread operator를 사용하기 위해서 babel모듈도 설치해줘야 합니다. npm install --save-dev babel-preset-stage-2 설치한 다음 .babelrc 파일에 다음과 같이 설정을 변경해 줍니다. .babelrc 파일은 프로젝트 제일 상단인 src 폴더와 같은 위치에 있습니다. 123456&#123; &quot;presets&quot;: [ [&quot;es2015&quot;, &#123;&quot;modules&quot;: false&#125;], [&quot;stage-2&quot;] ]&#125; src/components/portfolio/Portfolio.vue123456789101112131415161718...생략&lt;script&gt; // mapGetters 헬퍼를 사용하기 위해 vuex를 임포트해줍니다. import &#123; mapGetters &#125; from 'vuex'; import Stock from './Stock.vue'; export default &#123; // 위 예제에서 사용했던 data부분을 삭제하고 mapGetters 헬퍼를 사용하여 필요한 state를 맵핑해줍니다. computed: &#123; ...mapGetters(&#123; stocks: 'stockPortfolio' &#125;), &#125;, components: &#123; appStock: Stock &#125; &#125;&lt;/script&gt; mapGetters 헬퍼를 사용하여 Portfolio 컴포넌트에서 필요한 데이타를 조합해둔 stockPortfolio getter 를 stocks로 참조하여 사용합니다. 4. Stocks 컴포넌트 수정하기 이전 포스팅에서 만들었던 Stocks 컴포넌트의 Stock.vue에서 buyStock 메소드의 결과를 console.log로 확인하였었습니다. portfolio 모듈에 BUY_STOCK mutation을 생성하여서 이를 사용 할 수 있도록 수정해줍니다. 먼저 src/store/modules/stocks.js 에서 buyStock action의 commit(); 부분을 commit(&#39;BUY_STOCK&#39;, order); 로 수정합니다. 그리고 src/components/stocks/Stock.vue 에서 buyStock method의 console.log(order); 부분을 this.$store.dispatch(&#39;buyStock&#39;, order); 로 수정합니다. 모두 완료되었다면 아래 영상과 같이 Stock 컴포넌트와 Portfolio 컴포넌트 간에 State의 변화를 확인 할 수 있을것입니다.git clone 으로 프로젝트를 시작하셨다면 git checkout step05 로 이번 포스팅의 마지막 결과물을 확인 하실 수 있습니다.다음 포스팅은 마지막으로 몇가지 기능을 추가하고 vue-resource와 firebase를 활용해서 DB에 데이타를 저장하고 로드하는 기능까지 구현해보려고 합니다.필요하신 부분이나 보완할 점이 있다면 댓글로 의견 남겨주시기 바랍니다. 감사합니다. - 끝 - video, p img { width: 100%; box-shadow:0 10px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://hanwong.github.io/categories/VueJS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://hanwong.github.io/tags/vue/"},{"name":"vuejs","slug":"vuejs","permalink":"http://hanwong.github.io/tags/vuejs/"},{"name":"vue-resource","slug":"vue-resource","permalink":"http://hanwong.github.io/tags/vue-resource/"},{"name":"components","slug":"components","permalink":"http://hanwong.github.io/tags/components/"},{"name":"vue-router","slug":"vue-router","permalink":"http://hanwong.github.io/tags/vue-router/"},{"name":"vuex","slug":"vuex","permalink":"http://hanwong.github.io/tags/vuex/"},{"name":"tutorial","slug":"tutorial","permalink":"http://hanwong.github.io/tags/tutorial/"}]},{"title":"VueJS | Stock-Trader Project Tutorial (2)","slug":"vue-stock-trader-02","date":"2017-04-30T15:00:00.000Z","updated":"2017-09-21T13:35:46.000Z","comments":true,"path":"2017/05/01/vue-stock-trader-02/","link":"","permalink":"http://hanwong.github.io/2017/05/01/vue-stock-trader-02/","excerpt":"이 포스팅은 Max의 Vuejs 강좌 내용을 정리한 것이고, VueJS의 개념을 익히고 연습해보기 위한 튜토리얼을 다룬 글 입니다. 이번 포스팅에서는 프로젝트의 상태 관리를 위한 vuex 환경을 세팅하고 상태 변화에 따라 View의 변화를 확인 할 수 있도록 구현하고자 합니다.","text":"이 포스팅은 Max의 Vuejs 강좌 내용을 정리한 것이고, VueJS의 개념을 익히고 연습해보기 위한 튜토리얼을 다룬 글 입니다. 이번 포스팅에서는 프로젝트의 상태 관리를 위한 vuex 환경을 세팅하고 상태 변화에 따라 View의 변화를 확인 할 수 있도록 구현하고자 합니다. 1. Stock 컴포넌트 생성하기 가장 먼저 아래 그림과 같이 UI를 구현합니다. props: [&#39;stock&#39;] 는 상위 컴포넌트로 부터 데이타를 받아오기 위한 설정입니다. 그러면 현재 템플릿 안에서 와 같이 설정된 이름으로 변수를 설정 할 수 있습니다. 부모 컴포넌트에서 데이타를 전달 할 때는 전달할이름=&quot;부모컴포넌트내부데이타&quot;와 같이 부모 컴포넌트에서 자식 컴포넌트를 사용하는 태그 내에 속성으로 적용하면 됩니다. 그리고 데이타를 전송하기 위해서 Buy 버튼에는 클릭을 했을 때 buyStock 메소드를 사용하도록 설정해줍니다. 템플릿 내부의 디렉티브나 스크립트 부분에 사용하는 메소드 같은 기본적인 개념들은 VueJS에 아주 친절하게 설명되어 있으니 참고 하시기 바랍니다. src/components/stocks/Stock.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div class=\"col-md-4 col-sm-6\"&gt; &lt;div class=\"panel panel-success\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt; &#123;&#123; stock.name &#125;&#125; &lt;!-- 상위 컴포넌트로 부터 전달 받은 props 데이타 --&gt; &lt;small&gt;(Price: &#123;&#123; stock.price &#125;&#125; )&lt;/small&gt; &lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"pull-left\"&gt; &lt;input type=\"number\" class=\"form-control\" placeholder=\"Quantity\" v-model.number=\"quantity\" &gt; &lt;/div&gt; &lt;div class=\"pull-right\"&gt; &lt;button class=\"btn btn-success\" @click=\"buyStock\" :disabled=\"quantity &lt;= 0 || !Number.isInteger(quantity)\" &gt;Buy&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: ['stock'], data() &#123; return &#123; quantity: 0 &#125; &#125;, methods: &#123; buyStock() &#123; const order = &#123; stockId: this.stock.id, stockPrice: this.stock.price, quantity: this.quantity, &#125;; console.log(order); this.quantity = 0; &#125; &#125; &#125;&lt;/script&gt; 이전 포스팅에서 stocks 폴더 내에는 Stocks.vue, Stock.vue 파일을 생성하였습니다. 위에서 구현한 Stock.vue 내용은 위 그림처럼 데이타에 따라 하나의 박스를 그려 줍니다. 그리고 Stocks.vue에서는 가지고 있는 데이타에 따라서 Stock.vue를 반복적으로 사용합니다. 위에서 생성한 Stock.vue 파일을 import 해주고 components 에 사용할 이름을 설정해줍니다. 컴포넌트 이름을 설정할때는 보통 &lt;script&gt; 부분에서 camelCase 방식으로 선언하면 &lt;template&gt; 부분에서 kebab-case 방식으로 해당 컴포넌트를 사용 할 수 있습니다. 세팅된 컴포넌트는 data 에 있는 stocks 데이타에 따라 컴포넌트들을 출력해줍니다. src/components/stocks/Stocks.vue123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;app-stock v-for=\"stock in stocks\" :stock=\"stock\"&gt;&lt;/app-stock&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Stock from './Stock.vue'; export default &#123; data() &#123; return &#123; stocks: [ &#123; id: 1, name: 'BENZ', price: 200&#125;, &#123; id: 2, name: 'AUDI', price: 150&#125;, &#123; id: 3, name: 'HONDA', price: 180&#125;, &#123; id: 4, name: 'LEXUS', price: 195&#125; ] &#125; &#125;, components: &#123; appStock: Stock &#125; &#125;&lt;/script&gt; 2. Vuex 환경 세팅하기1. vuex 모듈 설치 및 파일 생성 먼저 npm install --save vuex로 vuex를 설치해줍니다. 그리고 아래 파일 구조에 맞게 store 폴더 내에 파일들을 생성해줍니다. 이 프로젝트에서 vuex 환경은 컴포넌트 단위 별로 modules 폴더에 분리해서 설정해주고 store.js 에 각각의 설정을 추가하여 사용합니다. vuex 관련 개념들은 Vuex에 친절하게 잘 나와 있습니다. VueJS는 대부분 관련 문서들이 한글화 되어 있어 참 좋습니다. ^^ 1234567891011121314151617src├── data│ └── stocks.js├── components│ ├── Header.vue│ ├── Home.vue│ ├── portfolio│ │ ├── Portfolio.vue│ │ └── Stock.vue│ └── stocks│ ├── Stock.vue│ └── Stocks.vue└── store ├── store.js └── modules ├── stocks.js └── portpolio.js 2. stocks.js 모듈 구현하기 컴포넌트 단위 별로 분리하여 설정하기로 하였기 때문에 Stocks 관련 설정 먼저 해줍니다. vuex를 구성하는 핵심 기능은 state, mutation, action, getter 입니다. 각각에 대한 상세한 개념은 Vuex-State 를 참고해주세요. 먼저 initStocks action을 사용 가능하도록 구현하기 위해 Stocks.vue 에서 배열 데이타를 컴포넌트에 직접 추가해서 사용했던 것을 별도 파일로 data 폴더에 분리시켜 가져오도록 하는 방식으로 데이타를 초기화 하는 기능을 구현합니다. data 폴더는 임시로 사용하는 것이고, 나중에 삭제하셔도 됩니다. 다다음 포스팅 쯤에서 vue-resource를 활용해서 firebase를 활용한 DB와 통신하는 부분을 구현 할 것입니다. buyStock, randomizeStocks action은 나중에 구현하겠습니다. src/data/stocks.js123456export default [ &#123; id: 1, name: 'BENZ', price: 200&#125;, &#123; id: 2, name: 'AUDI', price: 150&#125;, &#123; id: 3, name: 'HONDA', price: 180&#125;, &#123; id: 4, name: 'LEXUS', price: 195&#125;]; src/store/modules/stocks.js123456789101112131415161718192021222324252627282930313233343536373839import stocks from '../../data/stocks';const state = &#123; stocks: []&#125;;const mutations = &#123; 'SET_STOCKS' (state, stocks) &#123; state.stocks = stocks; &#125;, 'RND_STOCKS' (state) &#123; &#125;&#125;;const actions = &#123; buyStock: (&#123;commit&#125;, order) =&gt; &#123; commit(); &#125;, initStocks: (&#123;commit&#125;) =&gt; &#123; commit('SET_STOCKS', stocks); &#125;, randomizeStocks: (&#123;commit&#125;) =&gt; &#123; commit('RND_STOCKS'); &#125;&#125;;const getters = &#123; stocks: state =&gt; &#123; return state.stocks; &#125;&#125;;export default &#123; state, mutations, actions, getters&#125; 3. store.js, main.js 설정 추가하기 store.js 에서 사용 할 모든 모듈들을 등록해서 사용합니다. Vuex.Store 의 modules에 위에서 구현한 stocks 모듈을 등록해줍니다. src/store/store.js123456789101112import Vue from 'vue';import Vuex from 'vuex';import stocks from './modules/stocks'Vue.use(Vuex);export default new Vuex.Store(&#123; modules: &#123; stocks &#125;&#125;); store.js 는 main.js에 등록하여 사용합니다. src/main.js12345678910111213141516171819import Vue from 'vue';import VueRouter from 'vue-router';import App from './App.vue';import &#123; routes &#125; from './routes';import store from './store/store'; // store.js를 import 합니다.Vue.use(VueRouter);const router = new VueRouter(&#123; mode: 'history', routes&#125;);new Vue(&#123; el: '#app', router, store, // store를 등록해줍니다. render: h =&gt; h(App) 4. store 사용하기 main.js에 store를 등록하였기 때문에 이제 어떤 컴포넌트에서든지 별도의 설정 없이 store를 사용 할 수 있습니다. 컴포넌트 내에서 store 에 접근 하는 방법은 this.$store 입니다. 그리고 기능에 맞는 메소드를 사용하여 등록된 기능을 활용합니다. action은 this.$store.dispatch(&#39;action이름&#39;) 과 같이 사용하면 됩니다. src/App.vue12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=\"container\"&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Header from './components/Header.vue'; export default &#123; components: &#123; 'appHeader': Header &#125;, created() &#123; this.$store.dispatch('initStocks'); // store에 등록된 action을 사용합니다. &#125; &#125;&lt;/script&gt;&lt;style&gt; body &#123; padding: 30px; &#125;&lt;/style&gt; App.vue에서 initStocks action 으로 stocks state를 초기화 해주었습니다. Stocks.vue에서 store에 등록된 state를 사용하기 위해 data에 있던 stocks는 제거합니다. 등록되어 있는 state의 값을 값을 가져오기 위해 getter를 등록하고 사용해주어야 합니다. 컴포넌트 내에서 getter를 사용하는 방밥은 this.$store.getters.메소드이름 입니다. 자식 컴포넌트로 props를 전달하는 부분에서 본인이 이름이 햇갈려서 props의 이름을 propStock 으로 변경하였습니다. Stock.vue 에서도 전달 받는 props의 이름을 props: [&#39;propStock&#39;] 과 같이 변경해주고 관련된 변수들을 모두 변경해주셔야 합니다. src/components/stocks/Stocks.vue12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;app-stock v-for=\"stock in stocks\" :propStock=\"stock\"&gt;&lt;/app-stock&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Stock from './Stock.vue'; export default &#123; components: &#123; appStock: Stock &#125;, computed: &#123; stocks() &#123; return this.$store.getters.stocks; // getter로 현재 state 값을 가져옵니다. &#125; &#125; &#125;&lt;/script&gt; 모두 완료되었다면 아래와 같이 data/stocks.js에 있는 데이타에 따라 Stock 컴포넌트들이 출력 될 것입니다.git clone 으로 프로젝트를 시작하셨다면 git checkout step04 로 이번 포스팅의 마지막 결과물을 확인 하실 수 있습니다.다음 포스팅에서는 Portfolio 컴포넌트의 상태 설정을 추가하고 Stocks 컴포넌트와 함께 state의 변화에 따라 View 가 갱신 되는 부분까지 구현해보겠습니다.한번에 해보려고 했더니 너무 길어질 것 같아서 여기서 끊고 추후에 진행해보려 합니다. ㅎㅎ 별거 없는 내용인데도 손이 느려서 시간이 꽤 걸리네요.필요하신 부분이나 보완할 점이 있다면 댓글로 의견 남겨주시기 바랍니다. 감사합니다. - 끝 - video, p img { width: 100%; box-shadow:0 10px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); } .stock { max-width: 400px; } .stock img { width: 100%; box-shadow:0 10px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://hanwong.github.io/categories/VueJS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://hanwong.github.io/tags/vue/"},{"name":"vuejs","slug":"vuejs","permalink":"http://hanwong.github.io/tags/vuejs/"},{"name":"vue-resource","slug":"vue-resource","permalink":"http://hanwong.github.io/tags/vue-resource/"},{"name":"components","slug":"components","permalink":"http://hanwong.github.io/tags/components/"},{"name":"vue-router","slug":"vue-router","permalink":"http://hanwong.github.io/tags/vue-router/"},{"name":"vuex","slug":"vuex","permalink":"http://hanwong.github.io/tags/vuex/"},{"name":"tutorial","slug":"tutorial","permalink":"http://hanwong.github.io/tags/tutorial/"}]},{"title":"VueJS | Stock-Trader Project Tutorial (1)","slug":"vue-stock-trader-01","date":"2017-04-07T15:00:00.000Z","updated":"2018-06-25T14:30:38.000Z","comments":true,"path":"2017/04/08/vue-stock-trader-01/","link":"","permalink":"http://hanwong.github.io/2017/04/08/vue-stock-trader-01/","excerpt":"이 포스팅은 Max의 Vuejs 강좌 내용을 정리한 것이고, VueJS의 개념을 익히고 연습해보기 위한 튜토리얼을 다룬 글 입니다. 프로젝트 소개 이 프로젝트는 아래의 영상과 같이 VueJS를 활용해서 간단한 모의 주식 시스템을 만들어보는것 입니다. 주식 리스트들이 있고 End Day 버튼을 누르면 시세가 랜덤하게 변경되고 시세에 따라 사고 팔고하는 리스트가 저장되도록 만들어 보는것 입니다. vue-router, vue-resource, vuex를 활용해서 간단한 VueJS 프로젝트를 구성해보고 개념을 익히는 것이 목적입니다. 개인적으로 학습을 하면서 느꼈던 것이 이렇게 전체적으로 프로젝트를 구성하는 튜토리얼을 따라해보는 것이 많은 도움이되었던것 같아 본인의 개념도 좀 더 다지고 공부한 내용을 공유하고자 이 포스팅을 시작하게 되었습니다. 심도 있는 내용은 아니기 때문에 초보자 분들에게 도움이 되었으면 합니다.","text":"이 포스팅은 Max의 Vuejs 강좌 내용을 정리한 것이고, VueJS의 개념을 익히고 연습해보기 위한 튜토리얼을 다룬 글 입니다. 프로젝트 소개 이 프로젝트는 아래의 영상과 같이 VueJS를 활용해서 간단한 모의 주식 시스템을 만들어보는것 입니다. 주식 리스트들이 있고 End Day 버튼을 누르면 시세가 랜덤하게 변경되고 시세에 따라 사고 팔고하는 리스트가 저장되도록 만들어 보는것 입니다. vue-router, vue-resource, vuex를 활용해서 간단한 VueJS 프로젝트를 구성해보고 개념을 익히는 것이 목적입니다. 개인적으로 학습을 하면서 느꼈던 것이 이렇게 전체적으로 프로젝트를 구성하는 튜토리얼을 따라해보는 것이 많은 도움이되었던것 같아 본인의 개념도 좀 더 다지고 공부한 내용을 공유하고자 이 포스팅을 시작하게 되었습니다. 심도 있는 내용은 아니기 때문에 초보자 분들에게 도움이 되었으면 합니다. 이번 포스팅에서는 프로젝트에 사용될 컴포넌트 파일들과 폴더 구조를 생성하고 vue-router 로 라우팅 설정을 하여 페이지 이동이 가능한 내비게이션까지 만들고자 합니다. 1. 프로젝트 세팅 프로젝트 기본 세팅은 아래의 git 주소를 통해서 해도 되고 vue-cli를 통해서 기본 세팅을 하셔도 괜찮습니다. 프로젝트 기본 소스 복사 - git clone https://github.com/hanwong/vue-stock-trader.git 의존모듈 설치 - npm install 로컬 서버 실행 - npm run dev 2. 컴포넌트 파일 생성하기 먼저 아래의 파일 구조와 같이 src 폴더 아래에 화면을 구성할 컴포넌트 폴더와 파일을 생성합니다. 그리고 아래에 예제 코드를 각각의 .vue 파일에 추가하고 &lt;h1&gt; ... &lt;/h1&gt;의 내용을 각 파일에 맞게 수정해주면 됩니다. src/components/Home.vue12345&lt;template&gt; &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 12345678910src└── components ├── Header.vue ├── Home.vue ├── portfolio │ ├── Portfolio.vue │ └── Stock.vue └── stocks ├── Stock.vue └── Stocks.vue 3. vue-router 세팅하기 vue-router는 다들 아시다시피 VueJS에서 페이지 라우팅을 도와주는 고마운 모듈입니다. 이번 프로젝트에서는 페이지나 세팅할 내용이 많지 않아서 초기 세팅 이후에 별도로 추가할 내용이 없어 아주 간단한 라우팅 구성만 해주면 됩니다. 1. 가장 먼저 vue-router 모듈을 설치해줍니다.npm install --save vue-router 2. 라우트 설정들을 입력할 routes.js 파일을 src폴더 안에 생성합니다. 이 프로젝트에서 보여지는 페이지는 Home.vue, Stocks.vue, Portfolio.vue 입니다. 그래서 각 파일들을 각각의 url로 호출 할 수 있도록 라우팅을 구성합니다. Home.vue는 메인 화면이므로 url을 / 로 Stocks.vue는 /stocks, Portfolio.vue는 /portfolio 로 설정하였습니다. 코드의 내용은 각각의 컴포넌트들을 import 해주고 main.js 전체 설정에 추가 할 수 있도록 routes 배열 객체 안에 설정하여 export 합니다. 설정 내용은 아래의 코드와 같습니다. src/routes.js123456789import Home from './components/Home.vue';import Portfolio from './components/portfolio/Portfolio.vue';import Stocks from './components/stocks/Stocks.vue';export const routes = [ &#123; path: '/', component: Home &#125;, &#123; path: '/portfolio', component: Portfolio &#125;, &#123; path: '/stocks', component: Stocks &#125;,]; 3. routes.js 의 설정이 끝났으면 이 프로젝트의 전체 설정을 하는 main.js에 라우팅 설정을 추가해줍니다. 아래 코드에서 주석이 달려 있는 부분들의 코드를 main.js에 추가합니다. src/main.js123456789101112131415161718import Vue from 'vue';import VueRouter from 'vue-router'; // importing vue-router import App from './App.vue';import &#123; routes &#125; from './routes'; // importing routes Vue.use(VueRouter); // vue-router 플러그인 사용const router = new VueRouter(&#123; // vue-router 설정 mode: 'history', // hashbang 사용하지 않는 모드 설정 routes // 라우팅 설정&#125;);new Vue(&#123; el: '#app', router, // vue-router 설정을 Vue 인스턴스에 추가 render: h =&gt; h(App)&#125;); 4. 마지막으로 App.vue 파일에 라우팅의 시작점 설정을 해줍니다. 라우팅 시작점을 설정하는 태그 &lt;router-view&gt;&lt;/router-view&gt; 를 가장 상위 컴포넌트인 App.vue 에 추가해줍니다. src/App.vue123456&lt;template&gt; &lt;div class=\"container\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 라우팅 시작점 --&gt; &lt;/div&gt;&lt;/template&gt;... 여기까지 완료가 되면 라우팅 설정이 완료된것 입니다. 여기까지 에러 없이 동작이 된다고 하면 로컬 url 뒤에 /stocks나 /portfolio를 입력해서 페이지가 변환되는 것을 확인 할 수 있습니다. 4. 내비게이션을 만들기1. 마지막 단계로 설정된 url을 통해서 페이지를 이동하는 내비게이션을 만듭니다. Header.vue 파일에 아래의 코드를 추가합니다. 이 코드는 bootstrap ui 를 참고하여 제작되었습니다. url 링크를 설정하는 디렉티브는 &lt;router-link&gt;&lt;/router-link&gt; 이고, 이 디렉티브 안에 to=&quot;/stocks&quot;와 같이 속성을 추가해주면 해당 url로 이동 가능하게 됩니다. src/components/Header.vue1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;router-link to=\"/\" class=\"navbar-brand\"&gt;Stock Trader&lt;/router-link&gt; &lt;/div&gt; &lt;div class=\"collapse navbar-collapse\" &gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;router-link to=\"/portfolio\" activeClass=\"active\" tag=\"li\"&gt;&lt;a&gt;Portfolio&lt;/a&gt;&lt;/router-link&gt; &lt;router-link to=\"/stocks\" activeClass=\"active\" tag=\"li\"&gt;&lt;a&gt;Stocks&lt;/a&gt;&lt;/router-link&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;End Day&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;Save&amp;amp;Load&lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Save Data&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Load Data&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt;&lt;/template&gt; 2. 내비게이션으로 활용하기 위해 App.vue 에 Header.vue 컴포넌트를 추가하여 모든 페이지에서 보이도록 합니다. .vue 파일들은 한 파일안에 template, script, style 을 모두 설정할 수 있습니다. 먼저 &lt;script&gt; 영역에 Header.vue 객체로 사용할 수 있도록 import 해줍니다. 그리고 components 옵션 안에 디렉티브로 사용할 이름과 import한 객체를 설정해줍니다. 그 다음 &lt;template&gt; 영역에 router-view 부분은 Home, Stock, Portpolio 페이지가 보여지는 부분이므로 분리를 해주고, &lt;script&gt; 영역에서 설정한 디렉티브를 추가합니다. 컴포넌트의 이름 설정은 &lt;script&gt; 영역에서 camelCase로 설정하면 &lt;template&gt; 영역에서는 kebab-case 형태로 사용하여야 합니다. 그리고 간단하게 &lt;style&gt; 영역에는 패딩을 추가하여 맨 윗부분에 조금 간격을 두었습니다. src/App.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=\"container\"&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Header from './components/Header.vue'; export default &#123; components: &#123; 'appHeader': Header &#125; &#125;&lt;/script&gt;&lt;style&gt; body &#123; padding: 30px; &#125;&lt;/style&gt; 모두 완료되었다면 아래와 같은 화면이 출력될 것이고 내비게이션 버튼을 통해 페이지 이동이 가능할 것입니다.git clone 으로 프로젝트를 시작하셨다면 git checkout step02 로 이번 포스팅의 마지막 결과물을 확인 하실 수 있습니다.다음 편에서는 컴포넌트에 기능을 추가하고 데이터 상태 관리를 할 수 있는 vuex까지 다뤄보도록 하겠습니다.필요하신 부분이나 보완할 점이 있다면 댓글로 의견 남겨주시기 바랍니다. 감사합니다. - 끝 - p { margin: 0; } video, p img { width: 100%; box-shadow:0 10px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://hanwong.github.io/categories/VueJS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://hanwong.github.io/tags/vue/"},{"name":"vuejs","slug":"vuejs","permalink":"http://hanwong.github.io/tags/vuejs/"},{"name":"components","slug":"components","permalink":"http://hanwong.github.io/tags/components/"},{"name":"vue-router","slug":"vue-router","permalink":"http://hanwong.github.io/tags/vue-router/"},{"name":"vuex","slug":"vuex","permalink":"http://hanwong.github.io/tags/vuex/"},{"name":"tutorial","slug":"tutorial","permalink":"http://hanwong.github.io/tags/tutorial/"}]},{"title":"VueJS 공부하기 (3) | vue-resource - interceptors, $resource","slug":"vue-resource-firebase03","date":"2017-02-24T15:00:00.000Z","updated":"2017-05-06T05:14:15.000Z","comments":true,"path":"2017/02/25/vue-resource-firebase03/","link":"","permalink":"http://hanwong.github.io/2017/02/25/vue-resource-firebase03/","excerpt":"firebase를 아주 간단한 하게 활용해서 vue-resource를 아주 간단하게 체험해보기이 포스팅은 Max의 Vuejs 강좌 내용을 정리한것 입니다. 이번 포스팅에서는 interceptors와 resource에 대해서 알아 볼 것입니다.","text":"firebase를 아주 간단한 하게 활용해서 vue-resource를 아주 간단하게 체험해보기이 포스팅은 Max의 Vuejs 강좌 내용을 정리한것 입니다. 이번 포스팅에서는 interceptors와 resource에 대해서 알아 볼 것입니다. interceptors 인터셉터는 전역에서 request, response 프로세스 이전 이후에 필요한 조건들을 처리 할 수 있습니다. Intercepting Request– 요청을 인터셉트하는 예제에서는 간단히 POST 메소드로 요청시에 PUT 메소드로 변경해서 처리를 하는 것을 구현하였습니다. main.js123456789...Vue.http.interceptors.push((request, next) =&gt; &#123; console.log(request); if(request.method === 'POST') &#123; request.method = 'PUT'; &#125; next();&#125;);... Intercepting Response– 인터셉터를 사용하면 응답이 왔을 때에도 데이터를 필요한 형태의 구조로 변경해서 반환해주는 처리를 할 수 있도록 구현 할 수 있습니다. main.js12345... next(response =&gt; &#123; response.json = () =&gt; &#123; return &#123; message: response.body &#125; &#125;; &#125;);... resource resource를 사용하면 $http 보다 더욱 간편하고 좀 더 RESTful하게 사용 할 수 있는것 같습니다.– 전역에서는 Vue.resource로 사용 할 수 있고 개별 인스턴스 안에서는 this.$resource로 사용 할 수 있습니다.– resource(url, [params], [actions], [options]) 1. resource 기본 세팅 먼저 data에 resource를 활용할 객체를 하나 선언합니다. created() hook 함수 안에 $resource 서비스를 참조해줍니다. 그러면 resource를 활용하기 위한 기본적인 설정은 완료되었습니다. App.vue1234567891011data() &#123; return &#123; ... resource: &#123;&#125; &#125;;&#125;,......created() &#123; this.resource = this.$resource('data.json');&#125; 2. submit() 메소드 수정하기 기존에 $http를 사용하던 부분은 주석 처리를 해줍니다. 그리고 this.resource.save에 전송할 this.user를 argument로 넣습니다.– save와 같이 기본적으로 get, save, query, update, remove, delete 내장 메소드를 제공해줘서 편하게 사용할 수 있습니다. App.vue12345678910submit() &#123; // this.$http // .post('data.json', this.user) // .then(response =&gt; &#123; // console.log(response); // &#125;, error =&gt; &#123; // console.log(error); // &#125;); this.resource.save(&#123;&#125;, this.user);&#125; 3. fetchData() 메소드 수정하기 get을 사용하는 것도 크게 다르지 않습니다. $http 대신에 resource로 바꿔주면 됩니다.– this.resource.get()에 url이 포함 되어 있지 않은 이유는 위에서 초기 설정에 지정을 해두어서 필요하지 않은것입니다. 초기 설정에 url 값을 넣어주지 않는다면 각 메소드들에서 직접 설정해도 됩니다. App.vue123456789101112131415fetchData() &#123; // this.$http // .get('data.json') this.resource.get() .then(response =&gt; &#123; return response.json(); &#125;) .then(data =&gt; &#123; const resultArray = []; for ( let key in data ) &#123; resultArray.push(data[key]); &#125; this.users = resultArray; &#125;);&#125; 해당 예제와 관련된 소스는 아래 링크를 참조하시기 바랍니다.[resource예제] - 끝 -","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://hanwong.github.io/categories/VueJS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://hanwong.github.io/tags/vue/"},{"name":"vuejs","slug":"vuejs","permalink":"http://hanwong.github.io/tags/vuejs/"},{"name":"vue-resource","slug":"vue-resource","permalink":"http://hanwong.github.io/tags/vue-resource/"},{"name":"firebase","slug":"firebase","permalink":"http://hanwong.github.io/tags/firebase/"},{"name":"http","slug":"http","permalink":"http://hanwong.github.io/tags/http/"},{"name":"interceptors","slug":"interceptors","permalink":"http://hanwong.github.io/tags/interceptors/"},{"name":"resource","slug":"resource","permalink":"http://hanwong.github.io/tags/resource/"},{"name":"$resource","slug":"resource","permalink":"http://hanwong.github.io/tags/resource/"}]},{"title":"VueJS 공부하기 (2) | vue-resource - $http.get()","slug":"vue-resource-firebase02","date":"2017-02-11T15:00:00.000Z","updated":"2017-05-06T05:08:51.000Z","comments":true,"path":"2017/02/12/vue-resource-firebase02/","link":"","permalink":"http://hanwong.github.io/2017/02/12/vue-resource-firebase02/","excerpt":"firebase를 아주 간단한 하게 활용해서 vue-resource를 아주 간단하게 체험해보기이 포스팅은 Max의 Vuejs 강좌 내용을 정리한것 입니다. 이번 포스팅에서는 이전 포스트에 이어서 데이타베이스에서 데이타를 가져오는 방법에 대해서 알아 볼 것입니다.","text":"firebase를 아주 간단한 하게 활용해서 vue-resource를 아주 간단하게 체험해보기이 포스팅은 Max의 Vuejs 강좌 내용을 정리한것 입니다. 이번 포스팅에서는 이전 포스트에 이어서 데이타베이스에서 데이타를 가져오는 방법에 대해서 알아 볼 것입니다. 데이타를 저장할 변수 설정 가져올 데이타를 저장하는 변수 추가 users: [] 이 부분임 App.vue123456789data() &#123; return &#123; user: &#123; username: '', mail: '' &#125;, users: [] &#125;;&#125;, 데이타를 불러오는 메소드 설정 데이타를 호출하는 메소드 추가 첫번째 응답에서 response.json()로 받은 데이타는 promise 객체가 리턴된다. 다시 한번 then을 사용하면 우리가 원하는 데이타 만 가진 객체가 리턴된다. 그 데이타를 다시 한번 써먹을 수 있게 iteration 해주고 위에서 만든 변수에 저장한다. App.vue1234567891011121314fetchData() &#123; this.$http .get('https://your-project.firebaseio.com/data.json') .then(response =&gt; &#123; return response.json(); &#125;) .then(data =&gt; &#123; const resultArray = []; for ( let key in data ) &#123; resultArray.push(data[key]); &#125; this.users = resultArray; &#125;);&#125; fetchData 메소드를 실행할 버튼과 결과 리스트 만들기 버튼을 클릭 했을 때 fetchData 메소드로 데이타를 호출하는 버튼 생성 호출된 데이타가 users 배열에 저장되고 해당 데이터 결과를 리스트로 출력 App.vue123456&lt;button class=\"btn btn-primary\" @click=\"fetchData\"&gt;GetData&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item\" v-for=\"u in users\"&gt;&#123;&#123;u.username&#125;&#125; - &#123;&#123;u.mail&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 공통 url 설정 Vue.http.options.root 사용하기 url의 반복되는 root 부분을 main.js에 설정해 놓으면 하위 구조에서는 편하게 필요한 정보만 입력 할 수 있게 해줌 main.js1Vue.http.options.root = 'https://your-project.firebaseio.com/'; 위와 같이 설정해 놓으면 post, get 사용시 좀 더 편리할 듯 App.vue1234567...this.$http .post('data.json', this.user)...this.$http .get('data.json')... - 끝 - p img { width: 80%; box-shadow:0 10px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://hanwong.github.io/categories/VueJS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://hanwong.github.io/tags/vue/"},{"name":"vuejs","slug":"vuejs","permalink":"http://hanwong.github.io/tags/vuejs/"},{"name":"vue-resource","slug":"vue-resource","permalink":"http://hanwong.github.io/tags/vue-resource/"},{"name":"firebase","slug":"firebase","permalink":"http://hanwong.github.io/tags/firebase/"},{"name":"http","slug":"http","permalink":"http://hanwong.github.io/tags/http/"}]},{"title":"VueJS 공부하기 (1) | vue-resource - $http.post()","slug":"vue-resource-firebase01","date":"2017-02-10T15:00:00.000Z","updated":"2017-05-06T05:08:16.000Z","comments":true,"path":"2017/02/11/vue-resource-firebase01/","link":"","permalink":"http://hanwong.github.io/2017/02/11/vue-resource-firebase01/","excerpt":"firebase를 아주 간단한 하게 활용해서 vue-resource를 아주 간단하게 체험해보기이 포스팅은 Max의 Vuejs 강좌 내용을 정리한것 입니다.","text":"firebase를 아주 간단한 하게 활용해서 vue-resource를 아주 간단하게 체험해보기이 포스팅은 Max의 Vuejs 강좌 내용을 정리한것 입니다. VusJS 개발 환경 초기 세팅 필자 github의 소스를 모두 다운 받고 package.json 파일이 있는 위치에서 npm install github에서 소스를 다운로드 받는게 번거롭다는 생각이 든다면 크롬 브라우저의 octotree 확장 프로그램 설치를 권장함 패키지가 설치된 뒤에 npm run dev 하면 브라우저에 짠~ 하고 알아서 켜지고 아래와 같이 빈화면이 출력됨 vue-resource 설정 vue-resource를 main.js 파일에 설정함 12345...import VueResource from 'vue-resource'...Vue.use(VueResource);... 입력 폼 만둘기 기본 폼 동작 테스트 App.vue 파일 template, script 에 코드 작성 123456789&lt;div class=\"form-group\"&gt; &lt;label&gt;UserName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" v-model=\"user.username\"&gt;&lt;/div&gt;&lt;div class=\"form-group\"&gt; &lt;label&gt;Mail&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" v-model=\"user.mail\"&gt;&lt;/div&gt;&lt;button class=\"btn btn-primary\" @click=\"submit\"&gt;Submit&lt;/button&gt; 123456789101112131415export default &#123; data() &#123; return &#123; user: &#123; username: '', mail: '' &#125; &#125;; &#125;, methods: &#123; submit() &#123; console.log(this.user); &#125; &#125;&#125; firebase 초기 세팅 firebase로 테스팅을 위한 DB 환경 설정 계정 생성 프로젝트 생성 데이터베이스(Database) - 규칙(Rule) 에서 .read, .write 값을 모두 true로 변경 아주 간단하게 그림으로 따라 해보기 vue-resource - $http.post() $http.post()로 데이터 보내기 post 메소드 내에 첫번째 argument로 본인의 데이터베이스 주소 뒤에 data.json을 붙여서 입력하고, 다음 argument로 보낼 데이터를 입력 data.json을 붙이는 것은 내 데이터베이스의 data라는 공간에 json 형식으로 저장한다라고 생각하면 됨 promise를 당연히 지원해주므로 then 메소드에 성공, 실패에 대한 처리를 해줌 성공시 응답 메세지, 실패시 에러 메세지 12345678910111213... methods: &#123; submit() &#123; this.$http .post('https://your-project.firebaseio.com/data.json', this.user) .then(response =&gt; &#123; console.log(response); &#125;, error =&gt; &#123; console.log(error); &#125;); &#125; &#125;... 그러면 성공을 할 것이므로 아래와 같은 결과가 나올것임 - 끝 - p img { width: 80%; box-shadow:0 10px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://hanwong.github.io/categories/VueJS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://hanwong.github.io/tags/vue/"},{"name":"vuejs","slug":"vuejs","permalink":"http://hanwong.github.io/tags/vuejs/"},{"name":"vue-resource","slug":"vue-resource","permalink":"http://hanwong.github.io/tags/vue-resource/"},{"name":"firebase","slug":"firebase","permalink":"http://hanwong.github.io/tags/firebase/"},{"name":"http","slug":"http","permalink":"http://hanwong.github.io/tags/http/"}]},{"title":"Extended Isolate Float Technique","slug":"Isolate-Float","date":"2016-07-22T15:00:00.000Z","updated":"2017-05-06T05:14:55.000Z","comments":true,"path":"2016/07/23/Isolate-Float/","link":"","permalink":"http://hanwong.github.io/2016/07/23/Isolate-Float/","excerpt":"기존의 Isolate Float 기술을 이용해 다양한 사이즈의 박스들을 배치해보려고 이것저것 해보다가 조금 업데이트한 방법을 공유합니다.","text":"기존의 Isolate Float 기술을 이용해 다양한 사이즈의 박스들을 배치해보려고 이것저것 해보다가 조금 업데이트한 방법을 공유합니다. Floating boxCSS를 배우기 시작하면서 float만을 가지고 박스들을 원하는 위치에 배치하기는 쉽지 않았었습니다.약간의 크기 차이만 생겨도 다음 라인으로 떨어지거나 다음 라인에서도 튀어나와 있는 박스에 걸리거나 하면서 조금 복잡한 레이아웃을 구성하다 보면 뒷골 땡기는 일이 많이 생기죠.그리고 float된 박스들을 비율 값으로 배치할 때 발생하는 Sub-Pixel Problem 과 같은 것들도 있어 브라우저마다 다른 결과 때문에 애를 먹기도 한다고 합니다. 아직 실무를 해본 건 아니라 이 문제가 피부에 와 닿지는 않지만 아무튼 컨트롤 하기 어려운 아이라는 거죠.아무튼 조금 더 다양한 기법들을 배우기 시작하면서 Isolate Float 방식으로 float된 박스를 배치하는 방식을 알게 되었고 이것을 여러 예제에 이용해보고자 하였습니다. Isolate Float먼저 알게 된 기존의 Isolate technique 은 하나의 행 안에서 박스들을 이동하는 방식이었습니다. 하나의 행 안에서 박스들의 순서를 바꾸기도 쉽고 Sub-Pixel Problem도 해결할 수 있었습니다. Extended Isolate Float 이 방식은 제멋대로 이름을 한번 붙여 본 거고, 검색 능력이 부족한 것인지 같은 방식을 쓰는 사례는 찾지 못했습니다. 123.iso-box &#123; margin-right: -100%;&#125; 이 코드가 기존 방식의 핵심이죠. float: left된 박스들 모두에게 margin-right: -100%; 속성을 준 후에 margin-left 속성으로 그 페이지의 그리드 시스템에 맞게 배치하는 방식이었습니다. 그런데 한 디자인 예제를 구현해보면서 박스의 사이즈가 다양해 이 방법만으로는 레이아웃을 구성하기가 어려워서 고민하던 중에 margin-top을 활용해서 행 뿐만 아니라 열에도 Isolate Technique이 가능하지 않을까 생각이 들어서 한번 해보았습니다. 1234.iso-box &#123; margin-top: -100%; margin-right: -100%;&#125; 그리고 요런 식으로 그리드 시스템도 구성했습니다. 12345678910.iso-col-1 &#123; margin-top: calc(20%*0); &#125;.iso-col-2 &#123; margin-top: calc(20%*1); &#125;.iso-col-3 &#123; margin-top: calc(20%*2); &#125;.iso-col-4 &#123; margin-top: calc(20%*3); &#125;.iso-col-5 &#123; margin-top: calc(20%*4); &#125;.iso-row-1 &#123; margin-left: calc(20%*0); &#125;.iso-row-2 &#123; margin-left: calc(20%*1); &#125;.iso-row-3 &#123; margin-left: calc(20%*2); &#125;.iso-row-4 &#123; margin-left: calc(20%*3); &#125;.iso-row-5 &#123; margin-left: calc(20%*4); &#125; 해봤더니 되더라구요… 이렇게 배치된 박스들을 ~ .iso-box { margin-top: -100%; margin-right: -100%; } .iso-col-0 { margin-top: 0%; } .iso-col-1 { margin-top: 20%; } .iso-col-2 { margin-top: 40%; } .iso-col-3 { margin-top: 60%; } .iso-col-4 { margin-top: 80%; } .iso-row-0 { margin-left: 0%; } .iso-row-1 { margin-left: 20%; } .iso-row-2 { margin-left: 40%; } .iso-row-3 { margin-left: 60%; } .iso-row-4 { margin-left: 80%; } .container { width: 100%; } .wrapper1, .wrapper2 { width: 500px; height: 100px; margin-right: auto; margin-left: auto; margin-bottom: 50px; } .wrapper2 { height: 500px; outline: 3px solid #999999; } .container::after { display: block; content: ''; clear: both; } .box1, .box2, .box3, .box4, .box5 { float: left; width: 100px; height: 100px; line-height: 100px; text-align: center; } .box1 { background: #FF6666; color: #fff; } .box2 { background: #FFCC66; color: #fff; } .box3 { background: #66CCFF; color: #fff; } .box4 { background: #CC66FF; color: #fff; } .box5 { background: #FFA3CF; color: #fff; } box1box2box3box4box5 이렇게 내 맘대로 아무 데나 배치할 수 있습니다. box1box2box3box4box5box1box2box3box4box5 12&lt;div class=\"box1 iso-box iso-col-1 iso-row-0\"&gt;box1&lt;/div&gt;&lt;div class=\"box2 iso-box iso-col-2 iso-row-1\"&gt;box2&lt;/div&gt; 위와 같이 일정한 그리드 시스템을 가진 컨테이너 안에서는 각 박스 아이템의 클래스를 조정해서 엑셀을 사용하듯이(?) 아주 쉽게(?) ㅎㅎ 아무튼 원하는 레이아웃으로 박스를 배치하기에 조금 쉬운 방법이 아닐까 생각합니다. 그리고 물론 CSS에서 높이 값을 조절하는 데는 한계가 많죠. 이 방법도 박스들을 담고 있는 컨테이너가 높이 값을 가지고 있지 않거나 clearfix가 적용되어 있지 않다면 레이아웃이 무너질 수도 있을 것입니다. 아무튼 이 방법은 최근에 알게된 내용을 활용하다가 조금 확장해본 방법입니다. 요즘은 flex나 다른 프레임웍을 이용한 더 훌륭한 방법들도 많지만 이 방법도 어떤지 한번 참고 해보시고 보완할 점이나 더 좋은 방법들이 있다면 피드백 주시면 감사하겠습니다.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://hanwong.github.io/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://hanwong.github.io/tags/css/"},{"name":"grid","slug":"grid","permalink":"http://hanwong.github.io/tags/grid/"},{"name":"layout","slug":"layout","permalink":"http://hanwong.github.io/tags/layout/"},{"name":"isolate-float","slug":"isolate-float","permalink":"http://hanwong.github.io/tags/isolate-float/"},{"name":"isolate-technique","slug":"isolate-technique","permalink":"http://hanwong.github.io/tags/isolate-technique/"}]},{"title":"HTML & CSS Code Guide","slug":"Code-Guide","date":"2016-07-21T15:00:00.000Z","updated":"2017-05-06T05:10:49.000Z","comments":true,"path":"2016/07/22/Code-Guide/","link":"","permalink":"http://hanwong.github.io/2016/07/22/Code-Guide/","excerpt":"HTML, CSS 환경에서 코딩 할 때 알아두면 좋을 가이드들을 정리하고 있습니다.","text":"HTML, CSS 환경에서 코딩 할 때 알아두면 좋을 가이드들을 정리하고 있습니다. HTML CSS HTML Syntax HTML5 doctype Language attribute Internet Explorer compatibility mode Character encoding CSS and JavaScript includes Attribute order Reducing markup Sectioning markup Entity Code Syntax123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"ko-KR\"&gt;&lt;head&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"images/company-logo.png\" alt=\"Company\"&gt; &lt;h1 class=\"hello-world\"&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; Indentation 직계 자식 요소는 ・ ・ , Space 두칸을 이용하여 들여쓰기 한다. img 요소의 alt속성은 반드시 의미 있는 단어를 사용한다. 별다른 의미를 가지지 않는 이미지의 경우 background속성을 활용한다. HTML5 doctype1&lt;!DOCTYPE html&gt; HTML5 표준 사용을 위해 위의 Doctype을 사용한다. Doctype 코드는 반드시 문서 첫줄에 명시한다. 코드의 윗부분에는 절대로 아무런 요소도 삽입하지 않는다. Language attribute12345&lt;html lang=\"ko-KR\"&gt; [・・・] &lt;section lang=\"en\"&gt;English&lt;/section&gt; [・・・]&lt;/html&gt; 문서에 쓰이는 주언어를 html 요소에 삽입한다. 문서 중간에 다른 언어를 사용하는 경우 해당 언어의 속성을 명시한다. Internet Explorer compatibility mode1234567&lt;!--[if IE 6]&gt;&lt;html lang=\"ko-KR\" class=\"ie6\"&gt;&lt;![endif]--&gt;&lt;!--[if IE 7]&gt;&lt;html lang=\"ko-KR\" class=\"ie7\"&gt;&lt;![endif]--&gt;&lt;!--[if IE 8]&gt;&lt;html lang=\"ko-KR\" class=\"ie8\"&gt;&lt;![endif]--&gt;&lt;!--[if IE 9]&gt;&lt;html lang=\"ko-KR\" class=\"ie9\"&gt;&lt;![endif]--&gt;&lt;!--[if !IE]&gt;&lt;!--&gt;&lt;html lang=\"ko-KR\"&gt;&lt;!--&lt;![endif]--&gt;[・・・]&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt; IE 하위 버전 호환이 필요한 경우 IE 조건부 주석문을 활용하여 각 버전의 클래스를 명시한다. IE 호환성 모드에 대한 대응을 위해서 최소 IE 동작 버전을 명시한다. Character encoding1&lt;meta charset=\"UTF-8\"&gt; 텍스트 언어 인코딩을 UTF-8로 설정하여 모든 유니코드 문자를 표현할 수 있도록 설정하고, 깨지는 한글 문제를 해결한다. CSS and JavaScript includes1234&lt;link rel=\"stylesheet\" href=\"style.css\"&gt;&lt;style&gt;&lt;/style&gt;&lt;script src=\"script.js\"&gt;&lt;/script&gt; link, style, script 사용시 type 속성을 별도로 입력하지 않는다. Attribute order123&lt;a class=\"...\" id=\"...\" data-modal=\"toggle\" href=\"#\"&gt;Example link&lt;/a&gt;&lt;input class=\"form-control\" type=\"text\"&gt;&lt;img src=\"...\" alt=\"...\"&gt; 코드의 가독성 향상을 위해 HTML 태그 속성들을 특정한 순서로 명시한다. class id, name data-* src, for, type, href, value title, alt aria-*, role Reducing markup 의미 없는 div, span 요소의 사용을 자제한다. &lt;b&gt;, &lt;i&gt;, &lt;u&gt;, &lt;strike&gt;, &lt;s&gt;, &lt;big&gt;, &lt;small&gt;, &lt;center&gt;, &lt;font&gt; 등 표현에 국한된 요소는 사용하지 않는다. Sectioning markup12345678910&lt;header&gt;&lt;/header&gt;&lt;section class=\"header\"&gt; &lt;nav&gt;&lt;/nav&gt;&lt;/section&gt;&lt;main&gt; &lt;section&gt;&lt;/section&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/main&gt;&lt;section class=\"footer\"&gt;&lt;/section&gt;&lt;footer&gt;&lt;/footer&gt; Sectioning 요소 - section, article, main, nav, aside 화면의 전체 구조를 마크업 할 때 헤더와 푸터 영역에 Sectioning 요소를 포함하지 않으면 &lt;header&gt;, &lt;footer&gt; 태그를 사용하고, nav와 같은 Sectioning요소를 포함할 경우 &lt;section&gt;태그를 활용하여 명시한다. 헤더와 푸터 영역의 요소를 제외한 요소들은 main 요소 안에 명시한다. Entity Code1&lt;title&gt;코드 가이드 &amp;amp; 스타일&lt;/title&gt; 문서 내에서 특수문자는 반드시 Entity Code를 활용한다. 특히 title 영역에서는 &amp; 도 &amp;amp; Entity Code로 명시한다. title 이 인코딩 선언 요소보다 앞에 있을 경우에 &amp; 가 포함되어 있으면 인코딩이 제대로 이루어지지 않을 수 있다. 그래서 title를 인코딩 요소보다 뒤에 써주는 것이 좋다. CSS Declaration order Don’t use @import Classes Selectors Declaration order1234567891011121314151617181920212223242526272829.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box-model */ display: block; float: right; width: 100px; height: 100px; /* Typography */ font: normal 13px \"Helvetica Neue\", sans-serif; line-height: 1.5; color: #333; text-align: center; /* Visual */ background-color: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 3px; /* Misc */ opacity: 1;&#125; 다음과 같은 속성의 순서대로 선언한다. Positioning Box Typography Visual, Misc Don’t use @import1234&lt;link rel=\"stylesheet\" href=\"core.css\"&gt;&lt;style&gt; @import url(\"more.css\");&lt;/style&gt; CSS 파일을 연결할 때 @import를 사용하지 않고 link를 활용한다. @import는 직렬 방식으로 파일을 불러오기 때문에 성능에 영향을 미친다. Classes1234567.btn &#123; ... &#125;.btn-focus &#123; ... &#125;.btn-hover &#123; ... &#125;.line &#123; ... &#125;.line-focus &#123; ... &#125;.line-hover &#123; ... &#125; Class 명칭은 소문자를 사용하고, 단어 사이에는 - 로 구분한다. 지나친 축약 보다는 의미가 명확히 전달 가능한 이름을 사용한다. 인접한 부모 Class를 접두사로 활용한다. Selectors1234567/* Bad example */.btn.nav &#123; ... &#125;.line.nav &#123; ... &#125;/* Good example */.btn-nav &#123; ... &#125;.line-nav &#123; ... &#125; 선택자를 명시할 때 일반 요소를 지정하기 보다 Class를 지정하여 사용한다. 멀티클래스로 클래스를 나누어 사용하기 보다 접두사를 이용하여 독립적인 클래스를 선택자로 명시한다. [Scope CSS classes with prefixes]","categories":[{"name":"Guide","slug":"Guide","permalink":"http://hanwong.github.io/categories/Guide/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://hanwong.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://hanwong.github.io/tags/CSS/"},{"name":"CodeGuide","slug":"CodeGuide","permalink":"http://hanwong.github.io/tags/CodeGuide/"}]}]}